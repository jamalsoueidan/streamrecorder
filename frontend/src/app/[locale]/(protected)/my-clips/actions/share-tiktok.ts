"use server";

import api from "@/lib/api";
import { ClipShareRequestStateEnum } from "@/lib/types/strapi-autogenerated";

// Creator info response from TikTok
export interface CreatorInfo {
  creator_avatar_url: string;
  creator_username: string;
  creator_nickname: string;
  privacy_level_options: string[];
  comment_disabled: boolean;
  duet_disabled: boolean;
  stitch_disabled: boolean;
  max_video_post_duration_sec: number;
}

interface CreatorInfoResponse {
  data?: CreatorInfo;
  error?: {
    code: string;
    message: string;
  };
}

export async function getCreatorInfo(): Promise<{
  success: boolean;
  data?: CreatorInfo;
  error?: string;
}> {
  try {
    const tiktokConnection = await api.tiktok.meGetTiktoks();
    const tiktokData = tiktokConnection.data?.data;

    if (!tiktokData?.accessToken) {
      return { success: false, error: "No TikTok connection" };
    }

    let accessToken = tiktokData.accessToken;

    // Check if token is expired and refresh if needed
    const expiresAt = new Date(tiktokData.expiresAt || 0);
    if (new Date() >= expiresAt) {
      const refreshResult = await refreshTikTokToken(
        tiktokData.refreshToken!,
        tiktokData.documentId!,
      );
      if (!refreshResult.success || !refreshResult.accessToken) {
        return {
          success: false,
          error: "TikTok session expired. Please reconnect in Settings.",
        };
      }
      accessToken = refreshResult.accessToken;
    }

    const response = await fetch(
      "https://open.tiktokapis.com/v2/post/publish/creator_info/query/",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({}),
      },
    );

    const data: CreatorInfoResponse = await response.json();
    //console.log("TikTok creator info response:", JSON.stringify(data, null, 2));

    if (data.error?.code && data.error.code !== "ok") {
      return { success: false, error: data.error.message };
    }

    if (!data.data) {
      return { success: false, error: "No creator info returned" };
    }

    return { success: true, data: data.data };
  } catch (error) {
    console.error("Error fetching creator info:", error);
    return { success: false, error: "Failed to fetch creator info" };
  }
}

interface TikTokStatusResponse {
  data?: {
    status:
      | "PROCESSING_UPLOAD"
      | "PROCESSING_DOWNLOAD"
      | "SEND_TO_USER_INBOX"
      | "PUBLISH_COMPLETE"
      | "FAILED";
    fail_reason?: string;
    publicaly_available_post_id?: string[];
  };
  error?: {
    code: string;
    message: string;
  };
}

export async function checkTikTokStatus(publishId: string): Promise<{
  status: string;
  postId?: string;
  error?: string;
}> {
  try {
    const tiktokConnection = await api.tiktok.meGetTiktoks();
    const tiktokData = tiktokConnection.data?.data;

    if (!tiktokData?.accessToken) {
      return { status: "error", error: "No TikTok connection" };
    }

    let accessToken = tiktokData.accessToken;

    // Check if token is expired and refresh if needed
    const expiresAt = new Date(tiktokData.expiresAt || 0);
    if (new Date() >= expiresAt) {
      const refreshResult = await refreshTikTokToken(
        tiktokData.refreshToken!,
        tiktokData.documentId!,
      );
      if (!refreshResult.success || !refreshResult.accessToken) {
        return {
          status: "error",
          error: "TikTok session expired. Please reconnect in Settings.",
        };
      }
      accessToken = refreshResult.accessToken;
    }

    const response = await fetch(
      "https://open.tiktokapis.com/v2/post/publish/status/fetch/",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ publish_id: publishId }),
      },
    );

    const data: TikTokStatusResponse = await response.json();
    console.log("TikTok status response:", JSON.stringify(data, null, 2));

    if (data.error?.code && data.error.code !== "ok") {
      return { status: "error", error: data.error.message };
    }

    return {
      status: data.data?.status || "unknown",
      postId: data.data?.publicaly_available_post_id?.[0],
    };
  } catch (error) {
    console.error("Error checking TikTok status:", error);
    return { status: "error", error: "Failed to check status" };
  }
}

// Check TikTok status and update database if final status reached
export async function checkAndUpdateTikTokStatus(
  clipShareId: string,
  publishId: string,
): Promise<{
  status: string;
  updated: boolean;
  postId?: string;
  error?: string;
}> {
  const result = await checkTikTokStatus(publishId);

  if (result.status === "error") {
    return { status: "error", updated: false, error: result.error };
  }

  // Map TikTok status to our state
  let newState: ClipShareRequestStateEnum | null = null;

  if (result.status === "PUBLISH_COMPLETE") {
    newState = ClipShareRequestStateEnum.Completed;
  } else if (result.status === "FAILED") {
    newState = ClipShareRequestStateEnum.Failed;
  }

  // Update database if final status reached
  if (newState) {
    try {
      await api.clipShare.mePutClipSharesId({ id: clipShareId }, {
        data: {
          state: newState,
          data: {
            publishId,
            postId: result.postId,
            tiktokStatus: result.status,
            updatedAt: new Date().toISOString(),
          },
        },
      } as never);
      return {
        status: result.status,
        updated: true,
        postId: result.postId,
      };
    } catch (error) {
      console.error("Error updating clip share state:", error);
      return {
        status: result.status,
        updated: false,
        error: "Failed to update database",
      };
    }
  }

  return {
    status: result.status,
    updated: false,
    postId: result.postId,
  };
}

interface ShareToTikTokInput {
  clipDocumentId: string;
  title: string;
  privacyLevel: string;
  allowComments: boolean;
  allowDuet: boolean;
  allowStitch: boolean;
  brandContentToggle: boolean;
  brandOrganicToggle: boolean;
}

interface ShareResult {
  success: boolean;
  error?: string;
  publishId?: string;
}

interface TikTokInitResponse {
  data?: {
    publish_id: string;
    upload_url?: string; // Only returned for FILE_UPLOAD, not PULL_FROM_URL
  };
  error?: {
    code: string;
    message: string;
  };
}

export async function shareToTikTok({
  clipDocumentId,
  title,
  privacyLevel,
  allowComments,
  allowDuet,
  allowStitch,
  brandContentToggle,
  brandOrganicToggle,
}: ShareToTikTokInput): Promise<ShareResult> {
  try {
    // 1. Check if user has TikTok connected
    const tiktokConnection = await api.tiktok.meGetTiktoks();
    const tiktokData = tiktokConnection.data?.data;

    if (!tiktokData) {
      return {
        success: false,
        error: "TikTok account not connected. Please connect in Settings.",
      };
    }

    let accessToken = tiktokData.accessToken!;

    // 2. Check if token is expired and refresh if needed
    const expiresAt = new Date(tiktokData.expiresAt || 0);
    if (new Date() >= expiresAt) {
      const refreshResult = await refreshTikTokToken(
        tiktokData.refreshToken!,
        tiktokData.documentId!,
      );
      if (!refreshResult.success || !refreshResult.accessToken) {
        return {
          success: false,
          error: "TikTok session expired. Please reconnect in Settings.",
        };
      }
      accessToken = refreshResult.accessToken;
    }

    // 3. Get the clip details
    const clipResponse = await api.clip.meGetClipOne({ id: clipDocumentId });
    const clip = clipResponse.data?.data;

    if (!clip) {
      return { success: false, error: "Clip not found" };
    }

    // 4. Build video URL for TikTok to pull from (with ?tiktok for proxy mode)
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;
    const videoUrl = `${baseUrl}/clip/${clipDocumentId}/clip.mp4?tiktok`;

    // 5. Initialize TikTok upload with PULL_FROM_URL
    const initResponse = await fetch(
      "https://open.tiktokapis.com/v2/post/publish/video/init/",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json; charset=UTF-8",
        },
        body: JSON.stringify({
          post_info: {
            title: title.substring(0, 150),
            privacy_level: privacyLevel,
            disable_duet: !allowDuet,
            disable_comment: !allowComments,
            disable_stitch: !allowStitch,
            brand_content_toggle: brandContentToggle,
            brand_organic_toggle: brandOrganicToggle,
          },
          source_info: {
            source: "PULL_FROM_URL",
            video_url: videoUrl,
          },
        }),
      },
    );

    const initData: TikTokInitResponse = await initResponse.json();

    if (initData.error?.code && initData.error.code !== "ok") {
      console.error("TikTok init error:", initData.error);
      return {
        success: false,
        error: `TikTok error: ${initData.error.message}`,
      };
    }

    if (!initData.data?.publish_id) {
      return { success: false, error: "No publish ID returned from TikTok" };
    }

    // 7. Create clip-share record
    await api.clipShare.mePostClipShares({
      data: {
        clip: clipDocumentId,
        platform: "tiktok",
        state: ClipShareRequestStateEnum.Processing, // TikTok is still processing
        data: {
          publishId: initData.data.publish_id,
          title,
          privacyLevel,
          publishedAt: new Date().toISOString(),
        },
      },
    });

    return {
      success: true,
      publishId: initData.data.publish_id,
    };
  } catch (error) {
    console.error("Error sharing to TikTok:", error);
    return {
      success: false,
      error: "Failed to share to TikTok. Please try again.",
    };
  }
}

async function refreshTikTokToken(
  refreshToken: string,
  documentId: string,
): Promise<{ success: boolean; accessToken?: string }> {
  try {
    const response = await fetch(
      "https://open.tiktokapis.com/v2/oauth/token/",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          client_key: process.env.TIKTOK_CLIENT_KEY!,
          client_secret: process.env.TIKTOK_CLIENT_SECRET!,
          grant_type: "refresh_token",
          refresh_token: refreshToken,
        }),
      },
    );

    const data = await response.json();

    if (data.error) {
      console.error("Token refresh failed:", data.error);
      return { success: false };
    }

    // Update tokens in database
    const expiresAt = new Date(
      Date.now() + data.expires_in * 1000,
    ).toISOString();

    await api.tiktok.mePutTiktoksId(
      { id: documentId },
      {
        data: {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresAt,
        },
      },
    );

    return { success: true, accessToken: data.access_token };
  } catch (error) {
    console.error("Error refreshing token:", error);
    return { success: false };
  }
}
