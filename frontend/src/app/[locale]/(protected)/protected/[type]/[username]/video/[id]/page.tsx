"use client";

import { Box, Flex, Loader } from "@mantine/core";
import { useInfiniteQuery } from "@tanstack/react-query";
import { useParams, useRouter, useSearchParams } from "next/navigation";
import { useQueryStates } from "nuqs";
import { useCallback, useMemo } from "react";

import { VideoScrollPlayer } from "@/app/[locale]/(protected)/components/video/video-scroll-player";
import { Recording } from "@/lib/types/strapi-autogenerated";
import { fetchRecordingWithContext } from "../../actions/actions";
import { profileParsers } from "../../lib/search-params";

const SHELL_HEIGHT =
  "calc(100dvh - var(--app-shell-header-height, 0px) - var(--app-shell-footer-height, 0px) - var(--app-shell-padding) * 2)";

export default function VideoPage() {
  const router = useRouter();
  const params = useParams<{
    id: string;
    username: string;
    type: string;
  }>();
  const searchParams = useSearchParams();
  const [filters] = useQueryStates(profileParsers);

  const {
    data,
    fetchNextPage,
    fetchPreviousPage,
    hasNextPage,
    hasPreviousPage,
    isFetchingNextPage,
    isFetchingPreviousPage,
    isLoading,
  } = useInfiniteQuery({
    queryKey: [
      "video-recordings",
      params.type,
      params.username,
      params.id,
      filters,
    ],
    queryFn: ({ pageParam }) =>
      fetchRecordingWithContext(
        params.type,
        params.username,
        filters,
        params.id,
        pageParam,
      ),
    initialPageParam: 1, // This triggers the "find target" logic
    getNextPageParam: (lastPage) => {
      const { page = 1, pageCount = 0 } = lastPage.meta?.pagination ?? {};
      return page < pageCount ? page + 1 : undefined;
    },
    getPreviousPageParam: (firstPage) => {
      const { page = 1 } = firstPage.meta?.pagination ?? {};
      return page > 1 ? page - 1 : undefined;
    },
  });

  // Use the ACTUAL page numbers from responses for sorting
  const recordings = useMemo(() => {
    if (!data) return [];

    // Get actual page number from each response's meta
    const pagesWithActualNumbers = data.pages.map((page) => ({
      page,
      actualPage: page.meta?.pagination?.page ?? 1,
    }));

    // Sort by actual page number
    pagesWithActualNumbers.sort((a, b) => a.actualPage - b.actualPage);

    // Dedupe by documentId (just in case)
    const seen = new Set<string>();
    const result: Recording[] = [];

    for (const { page } of pagesWithActualNumbers) {
      for (const recording of page.data) {
        if (!seen.has(recording.documentId!)) {
          seen.add(recording.documentId!);
          result.push(recording);
        }
      }
    }

    return result;
  }, [data]);

  const handleVisibleChange = useCallback(
    (recording: Recording) => {
      const basePath = `/${params.type}/${decodeURIComponent(
        params.username,
      )}/video/${recording.documentId}`;

      const search = searchParams.toString();
      const url = search ? `${basePath}?${search}` : basePath;
      window.history.replaceState(null, "", url);
    },
    [params.type, params.username, searchParams],
  );

  const handleNotFound = () => {
    router.replace(`/${params.type}/${decodeURIComponent(params.username)}`);
  };

  const handleClose = () => {
    // Go back to profile page
    router.push(`/${params.type}/${decodeURIComponent(params.username)}`);
  };

  if (isLoading) {
    return (
      <Box h={SHELL_HEIGHT} pos="relative">
        <Flex h="100%" justify="center" align="center">
          <Loader size="lg" />
        </Flex>
      </Box>
    );
  }

  return (
    <Box
      h={SHELL_HEIGHT}
      pos="relative"
      style={{ borderRadius: "var(--mantine-radius-md)", overflow: "hidden" }}
    >
      <VideoScrollPlayer
        recordings={recordings}
        initialId={params.id}
        hasNextPage={hasNextPage}
        hasPreviousPage={hasPreviousPage}
        isFetchingNextPage={isFetchingNextPage}
        isFetchingPreviousPage={isFetchingPreviousPage}
        onFetchNextPage={fetchNextPage}
        onFetchPreviousPage={fetchPreviousPage}
        onVisibleChange={handleVisibleChange}
        onClose={handleClose}
        onNotFound={handleNotFound}
        showCloseButton={true}
        height="100%"
      />
    </Box>
  );
}
