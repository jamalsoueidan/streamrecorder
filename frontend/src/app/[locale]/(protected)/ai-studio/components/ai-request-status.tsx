"use client";

import { Role, useIsRole } from "@/app/providers/ability-provider";
import {
  AiRequest,
  Clip,
  Follower,
} from "@/lib/types/strapi-autogenerated";
import {
  Alert,
  Badge,
  Box,
  Card,
  Collapse,
  Group,
  Progress,
  SimpleGrid,
  Stack,
  Text,
  UnstyledButton,
} from "@mantine/core";
import {
  IconCheck,
  IconChevronDown,
  IconChevronRight,
  IconClock,
  IconLoader,
  IconX,
} from "@tabler/icons-react";
import { useFormatter, useLocale, useTranslations } from "next-intl";
import { useState } from "react";
import { ClipPreview } from "../../my-clips/components/clip-preview";
import {
  deriveRequestState,
  getVisibleTaskCounts,
} from "../utils/derive-state";

interface Props {
  aiRequest: AiRequest;
  follower?: Follower | null;
}

// Get all localized versions of follower (current + localizations)
function getLocalizedFollowers(follower?: Follower | null): Follower[] {
  if (!follower) return [];
  const all: Follower[] = [follower];
  if (follower.localizations && Array.isArray(follower.localizations)) {
    all.push(...(follower.localizations as Follower[]));
  }
  return all;
}

// Parse task output to extract counts
function getTaskOutputInfo(task: {
  type?: string;
  state?: string;
  output?: any;
}): { type: "clips" | "memes"; count: number } | null {
  if (task.state !== "completed" || !task.output) return null;

  const data: any = task.output;
  if (task.type === "clips::prompt" && data.clips) {
    return { type: "clips", count: data.clips.length };
  }
  if (task.type === "memes::prompt" && data.memes) {
    return { type: "memes", count: data.memes.length };
  }

  return null;
}

// Get clips from task output
function getClipsFromOutput(task: {
  type?: string;
  state?: string;
  output?: any;
}): Clip[] {
  if (task.state !== "completed" || !task.output) return [];
  if (task.type !== "clips::run") return [];

  const data: any = task.output;
  return Array.isArray(data.clips) ? data.clips : [];
}

// Calculate task duration
function getTaskDuration(task: {
  createdAt?: string;
  updatedAt?: string;
  state?: string;
}): string | null {
  if (task.state !== "completed" && task.state !== "failed") return null;
  if (!task.createdAt || !task.updatedAt) return null;

  const start = new Date(task.createdAt).getTime();
  const end = new Date(task.updatedAt).getTime();
  const durationMs = end - start;

  if (durationMs < 1000) return `${durationMs}ms`;
  if (durationMs < 60000) return `${Math.round(durationMs / 1000)}s`;
  const minutes = Math.floor(durationMs / 60000);
  const seconds = Math.round((durationMs % 60000) / 1000);
  return `${minutes}m ${seconds}s`;
}

// Format clip duration
function formatDuration(seconds?: number): string {
  if (!seconds) return "";
  const mins = Math.floor(seconds / 60);
  const secs = Math.round(seconds % 60);
  return mins > 0 ? `${mins}:${secs.toString().padStart(2, "0")}` : `${secs}s`;
}

export function AiRequestStatus({ aiRequest, follower }: Props) {
  const t = useTranslations("protected.aiStudio.status");
  const format = useFormatter();
  const locale = useLocale();
  const isAdmin = useIsRole("admin");
  const [expandedTasks, setExpandedTasks] = useState<Set<string>>(new Set());

  const toggleTask = (taskId: string) => {
    setExpandedTasks((prev) => {
      const next = new Set(prev);
      if (next.has(taskId)) {
        next.delete(taskId);
      } else {
        next.add(taskId);
      }
      return next;
    });
  };

  const tasks = aiRequest.ai_tasks || [];
  const derivedState = deriveRequestState(aiRequest, isAdmin);
  const { expectedTotal, completedTasks } = getVisibleTaskCounts(
    aiRequest,
    isAdmin,
  );
  const progress =
    expectedTotal > 0 ? (completedTasks / expectedTotal) * 100 : 0;

  const stateColors: Record<string, string> = {
    pending: "yellow",
    processing: "blue",
    completed: "green",
    failed: "red",
  };

  const stateIcons: Record<string, React.ReactNode> = {
    pending: <IconClock size={16} color="var(--mantine-color-yellow-6)" />,
    processing: (
      <IconLoader
        size={16}
        className="animate-spin"
        color="var(--mantine-color-blue-6)"
      />
    ),
    completed: <IconCheck size={16} color="var(--mantine-color-green-6)" />,
    failed: <IconX size={16} color="var(--mantine-color-red-6)" />,
  };

  return (
    <Stack gap="md">
      {derivedState === "pending" ? (
        <Alert
          icon={<IconClock size={20} />}
          color="yellow"
          title={t("pendingTitle")}
        >
          {t("pendingMessage")}
        </Alert>
      ) : (
        <Card withBorder padding="md">
          <Stack gap="sm">
            <Group justify="space-between">
              <Text fw={500}>{t("progress")}</Text>
              <Text
                size="sm"
                c={derivedState === "completed" ? "green" : "dimmed"}
              >
                {derivedState === "completed"
                  ? t("state.completed")
                  : `${completedTasks} / ${expectedTotal}`}
              </Text>
            </Group>
            <Progress
              value={progress}
              color={stateColors[derivedState]}
              size="lg"
              animated={derivedState === "processing"}
            />
          </Stack>
        </Card>
      )}

      {tasks.length > 0 && (
        <Stack gap="sm">
          <Text fw={500}>{t("tasks")}</Text>
          {tasks.map((task) => {
            const outputInfo = getTaskOutputInfo(task);
            const clips = getClipsFromOutput(task);
            const duration = getTaskDuration(task);
            const hasClips = clips.length > 0;
            const isProfileTask =
              task.type === "profile::run" && task.state === "completed";
            const localizedFollowers = isProfileTask
              ? getLocalizedFollowers(follower)
              : [];
            const hasProfile = localizedFollowers.length > 0;
            const isExpanded = expandedTasks.has(task.documentId || "");
            const hasExpandableContent = hasClips || hasProfile;
            const isProfileTaskType = task.type?.startsWith("profile::");

            const taskCard = (
              <Card key={task.documentId} withBorder padding="sm">
                <Stack gap="xs">
                  <Group justify="space-between">
                    <Stack gap={2}>
                      <Group gap="xs">
                        {stateIcons[task.state || "pending"]}
                        <Text size="sm" tt="capitalize">
                          {task.type}
                        </Text>
                        {duration && (
                          <Text size="xs" c="dimmed">
                            ({duration})
                          </Text>
                        )}
                      </Group>
                      {task.updatedAt && (
                        <Text size="xs" c="dimmed" ml={24}>
                          {format.relativeTime(new Date(task.updatedAt))}
                        </Text>
                      )}
                    </Stack>
                    <Group gap="xs">
                      {outputInfo && (
                        <Text size="xs" c="dimmed">
                          {outputInfo.type === "clips"
                            ? t("clipsCount", { count: outputInfo.count })
                            : t("memesCount", { count: outputInfo.count })}
                        </Text>
                      )}
                      {hasExpandableContent && (
                        <UnstyledButton
                          onClick={() => toggleTask(task.documentId || "")}
                        >
                          <Group gap={4}>
                            <Text size="xs" c="blue">
                              {hasClips
                                ? t("clipsCount", { count: clips.length })
                                : t("localesCount", { count: localizedFollowers.length })}
                            </Text>
                            {isExpanded ? (
                              <IconChevronDown
                                size={14}
                                color="var(--mantine-color-blue-6)"
                              />
                            ) : (
                              <IconChevronRight
                                size={14}
                                color="var(--mantine-color-blue-6)"
                              />
                            )}
                          </Group>
                        </UnstyledButton>
                      )}
                      <Badge
                        color={stateColors[task.state || "pending"]}
                        variant="light"
                        size="sm"
                      >
                        {t(`state.${task.state || "pending"}`)}
                      </Badge>
                    </Group>
                  </Group>

                  {hasClips && (
                    <Collapse in={isExpanded}>
                      <Box mt="sm">
                        <SimpleGrid cols={{ base: 1, sm: 2 }} spacing="sm">
                          {clips.map((clip, index) => (
                            <Card
                              key={clip.documentId || index}
                              withBorder
                              padding={0}
                              radius="md"
                            >
                              <ClipPreview clip={clip} locale={locale} />
                              <Stack gap={4} p="xs">
                                <Group justify="space-between" wrap="nowrap">
                                  <Text size="sm" fw={500} lineClamp={1}>
                                    {clip.title || t("clipFallback", { index: index + 1 })}
                                  </Text>
                                  {clip.viral_score && (
                                    <Badge
                                      size="xs"
                                      variant="light"
                                      color="violet"
                                    >
                                      {clip.viral_score}%
                                    </Badge>
                                  )}
                                </Group>
                                <Group gap="xs">
                                  {clip.duration && (
                                    <Text size="xs" c="dimmed">
                                      {formatDuration(clip.duration)}
                                    </Text>
                                  )}
                                  {clip.tags && (
                                    <Text size="xs" c="dimmed" lineClamp={1}>
                                      {clip.tags}
                                    </Text>
                                  )}
                                </Group>
                              </Stack>
                            </Card>
                          ))}
                        </SimpleGrid>
                      </Box>
                    </Collapse>
                  )}

                  {hasProfile && (
                    <Collapse in={isExpanded}>
                      <Box mt="sm">
                        <Stack gap="sm">
                          {localizedFollowers.map((f) => (
                            <Card
                              key={f.locale || "default"}
                              withBorder
                              padding="sm"
                              radius="md"
                            >
                              <Stack gap="xs">
                                <Group justify="space-between">
                                  <Badge size="sm" variant="light">
                                    {f.locale?.toUpperCase() || t("default")}
                                  </Badge>
                                </Group>
                                {f.tagline && (
                                  <Box>
                                    <Text size="xs" c="dimmed" mb={2}>
                                      {t("tagline")}
                                    </Text>
                                    <Text size="sm">{f.tagline}</Text>
                                  </Box>
                                )}
                                {f.description && (
                                  <Box>
                                    <Text size="xs" c="dimmed" mb={2}>
                                      {t("description")}
                                    </Text>
                                    <Text size="sm">{f.description}</Text>
                                  </Box>
                                )}
                              </Stack>
                            </Card>
                          ))}
                        </Stack>
                      </Box>
                    </Collapse>
                  )}
                </Stack>
              </Card>
            );

            // Wrap profile tasks with admin-only Role
            if (isProfileTaskType) {
              return (
                <Role key={task.documentId} is="admin">
                  {taskCard}
                </Role>
              );
            }

            return taskCard;
          })}
        </Stack>
      )}
    </Stack>
  );
}
