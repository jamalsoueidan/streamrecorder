"use client";

import { generateAvatarUrl } from "@/app/lib/avatar-url";
import { safeRelativeTime } from "@/app/lib/safe-relative-time";
import { AiRequest } from "@/lib/types/strapi-autogenerated";
import {
  Avatar,
  Badge,
  Box,
  Button,
  Card,
  Center,
  Flex,
  Group,
  Progress,
  Stack,
  Text,
} from "@mantine/core";
import { IconEye, IconTrash } from "@tabler/icons-react";
import { useFormatter, useNow, useTranslations } from "next-intl";
import Image from "next/image";
import Link from "next/link";
import { MiniPlayer } from "../../components/video/mini-player";

interface Props {
  aiRequest: AiRequest;
}

export function AiRequestCard({ aiRequest }: Props) {
  const format = useFormatter();
  const now = useNow({ updateInterval: 1000 * 30 });
  const t = useTranslations("protected.aiStudio");

  const stateColors: Record<string, string> = {
    pending: "yellow",
    processing: "blue",
    completed: "green",
    failed: "red",
  };

  const follower = aiRequest.follower;
  const recording = aiRequest.recording;
  const isRecordingDeleted = !recording;
  const state = aiRequest.state || "pending";

  const renderStatus = () => {
    const isAnimated = state === "pending" || state === "processing";

    return (
      <Progress.Root size={40} radius="md">
        <Progress.Section
          value={100}
          color={stateColors[state]}
          animated={isAnimated}
        >
          <Progress.Label lh={1.4}>{t(`state.${state}`)}</Progress.Label>
        </Progress.Section>
      </Progress.Root>
    );
  };

  return (
    <Card radius="md" withBorder>
      <Stack gap="xs">
        {/* Header: Avatar, username, time, options */}
        <Flex justify="space-between" align="center">
          <Group gap="sm" wrap="nowrap">
            <Avatar size={36} radius="xl">
              {follower?.avatar?.url && (
                <Image
                  src={generateAvatarUrl(follower.avatar.url)}
                  alt={follower.username || "Avatar"}
                  width={36}
                  height={36}
                />
              )}
            </Avatar>
            <Stack gap={0}>
              <Text fw={500} size="sm" truncate maw={140}>
                {follower?.username || t("unknownCreator")}
              </Text>
              <Text size="xs" c="dimmed" suppressHydrationWarning>
                {safeRelativeTime(format, aiRequest.createdAt, { now })}
              </Text>
            </Stack>
          </Group>
          <Group gap={4}>
            {aiRequest.generateClips && (
              <Badge variant="light" size="xs">
                {t("options.clips")}
              </Badge>
            )}
            {aiRequest.generateMemes && (
              <Badge variant="light" size="xs">
                {t("options.memes")}
              </Badge>
            )}
            {aiRequest.generateProfile && (
              <Badge variant="light" size="xs">
                {t("options.profile")}
              </Badge>
            )}
          </Group>
        </Flex>

        {/* Video Preview */}
        <Box pos="relative" style={{ aspectRatio: "16/9" }}>
          {isRecordingDeleted ? (
            <Center
              h="100%"
              bg="dark.6"
              style={{ borderRadius: "var(--mantine-radius-md)" }}
            >
              <Stack align="center" gap="xs">
                <IconTrash size={32} color="var(--mantine-color-gray-6)" />
                <Text size="sm" c="dimmed">
                  {t("recordingDeleted.badge")}
                </Text>
              </Stack>
            </Center>
          ) : (
            <MiniPlayer documentId={recording?.documentId!} />
          )}
        </Box>

        {/* Status and View Details */}
        <Stack gap="xs">
          {renderStatus()}
          <Button
            component={Link}
            href={`/ai-studio/${aiRequest.documentId}`}
            size="md"
            variant="light"
            leftSection={<IconEye size={18} />}
            fullWidth
          >
            {t("viewDetails")}
          </Button>
        </Stack>
      </Stack>
    </Card>
  );
}
