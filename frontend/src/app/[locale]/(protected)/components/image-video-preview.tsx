"use client";

import { useUser } from "@/app/providers/user-provider";
import {
  FollowerTypeEnum,
  Recording,
  SourceStateEnum,
} from "@/lib/types/strapi-autogenerated";
import { Anchor, Badge, Box, Button, CopyButton } from "@mantine/core";
import { useTranslations } from "next-intl";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { useRef, useState } from "react";

import {
  getProfileUrl,
  SOCIAL_URL_PATTERNS,
} from "@/app/components/open-social";
import Image from "next/image";
import { useIsNew } from "../hooks/use-is-new";
import { FollowerTypeIcon } from "./follower-type-icon";
import { MiniPlayer } from "./video/mini-player";
import { formatDuration } from "./video/player-utils";

interface Props {
  recording: Recording;
  username: string;
  type: FollowerTypeEnum;
}

export function ImageVideoPreview({ recording, type, username }: Props) {
  const { isNew } = useIsNew();
  const t = useTranslations("protected.common");

  const user = useUser();
  const searchParams = useSearchParams();
  const [showVideo, setShowVideo] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const router = useRouter();

  const sources = recording.sources;
  const totalDuration =
    sources?.reduce((sum, s) => sum + (s.duration || 0), 0) || 0;

  const isRecording = sources?.some(
    (s) => s.state === SourceStateEnum.Recording,
  );

  const hasSources = sources && sources.length > 0;
  const uri = hasSources ? `/video/${recording.documentId}/` : null;

  const getHref = (time?: number) => {
    const params = new URLSearchParams(searchParams.toString());
    if (time && time > 0) {
      params.set("t", Math.floor(time).toString());
    }
    return `${getProfileUrl(recording.follower)}/video/${
      recording.documentId
    }?${params.toString()}`;
  };

  const handleMouseEnter = () => {
    if (!sources || sources.length === 0 || isRecording) return;
    timeoutRef.current = setTimeout(() => {
      setShowVideo(true);
    }, 1500);
  };

  const handleMouseLeave = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    setShowVideo(false);
  };

  const handleTimeClick = (currentTime: number) => {
    router.push(getHref(currentTime));
  };

  return (
    <div
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      style={{
        aspectRatio: "16/9",
        position: "relative",
        overflow: "hidden",
        borderRadius: "var(--mantine-radius-md)",
      }}
    >
      <Anchor
        component={Link}
        href={getHref()}
        style={{
          pointerEvents: isRecording ? "none" : "auto",
          cursor: isRecording ? "not-allowed" : "pointer",
        }}
      >
        <Image
          alt=""
          src={
            hasSources
              ? isRecording
                ? uri + "screenshot.jpg"
                : uri + "preview.jpg"
              : "/assets/placeholder/180x280/black/white?text=Recording started"
          }
          loading="lazy"
          fill
          sizes="(max-width: 768px) 180px, 280px"
          style={{
            borderRadius: "var(--mantine-radius-md)",
            objectFit: "cover",
            objectPosition: "center center",
            display: showVideo ? "none" : "block",
            ...(isRecording && {
              border: "2px solid red",
            }),
          }}
        />
      </Anchor>

      {isRecording && (
        <Badge
          component="a"
          href={SOCIAL_URL_PATTERNS[type](username)}
          target="_blank"
          rel="noopener noreferrer"
          pos="absolute"
          top={8}
          left={8}
          radius="sm"
          color="red"
          variant="filled"
          size="sm"
          style={{ cursor: "pointer", zIndex: 10 }}
          leftSection={
            <Box
              w={8}
              h={8}
              bg="white"
              style={{ borderRadius: "50%", animation: "pulse 1s infinite" }}
            />
          }
        >
          {t("recordings.recordCount", {
            count: sources && sources?.length > 1 ? `#${sources.length}` : "",
          })}
        </Badge>
      )}

      {isNew(recording) ? (
        <Badge
          radius="md"
          variant="outline"
          size="md"
          color="white"
          bg="green"
          style={{
            position: "absolute",
            bottom: 8,
            left: 8,
          }}
        >
          {t("recordings.newRecording")}
        </Badge>
      ) : null}

      {showVideo && sources && (
        <MiniPlayer sources={sources} onTimeClick={handleTimeClick} />
      )}

      <FollowerTypeIcon
        type={type}
        color="black"
        opacity={0.8}
        pos="absolute"
        top={10}
        right={8}
        style={{
          pointerEvents: "none",
        }}
      />

      {isRecording && user?.role?.type === "superadmin" ? (
        <CopyButton
          value={
            recording.sources
              ?.find((s) => s.state === "recording")
              ?.executionId?.toString() || ""
          }
        >
          {({ copied, copy }) => (
            <Button
              size="compact-xs"
              color={copied ? "gray" : "black"}
              style={{
                position: "absolute",
                bottom: 8,
                right: 8,
              }}
              onClick={copy}
            >
              {
                recording.sources?.find((s) => s.state === "recording")
                  ?.executionId
              }
            </Button>
          )}
        </CopyButton>
      ) : null}

      {totalDuration > 0 && !showVideo && !isRecording && (
        <div
          style={{
            position: "absolute",
            bottom: 8,
            right: 8,
            backgroundColor: "rgba(0, 0, 0, 0.8)",
            color: "white",
            padding: "2px 6px",
            borderRadius: 4,
            fontSize: 12,
            fontWeight: 500,
            pointerEvents: "none",
          }}
        >
          {formatDuration(totalDuration)}
        </div>
      )}
    </div>
  );
}
