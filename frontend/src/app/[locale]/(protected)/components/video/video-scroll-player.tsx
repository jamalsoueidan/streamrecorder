"use client";

import { Recording } from "@/lib/types/strapi-autogenerated";
import {
  ActionIcon,
  Box,
  Flex,
  Group,
  Loader,
  Stack,
  Text,
} from "@mantine/core";
import {
  IconChevronDown,
  IconChevronUp,
  IconVideoOff,
  IconX,
} from "@tabler/icons-react";
import {
  useCallback,
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { VideoPlayer } from "./video-player";

interface VideoScrollPlayerProps {
  recordings: Recording[];
  initialId: string;
  isLoading?: boolean;
  hasNextPage?: boolean;
  hasPreviousPage?: boolean;
  isFetchingNextPage?: boolean;
  isFetchingPreviousPage?: boolean;
  onFetchNextPage?: () => void;
  onFetchPreviousPage?: () => void;
  onVisibleChange?: (recording: Recording) => void;
  onClose?: () => void;
  onNotFound?: () => void;
  showCloseButton?: boolean;
  height?: string;
}

export function VideoScrollPlayer({
  recordings,
  initialId,
  isLoading,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
  onFetchNextPage,
  onFetchPreviousPage,
  onVisibleChange,
  onClose,
  onNotFound,
  showCloseButton = true,
  height = "100dvh",
}: VideoScrollPlayerProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const slideRefs = useRef<Map<number, HTMLDivElement>>(new Map());
  const [visibleIndex, setVisibleIndex] = useState<number | null>(null);
  const hasScrolledToInitial = useRef(false);

  // Track the currently visible video's documentId (not index, since index can shift)
  const visibleDocumentId = useRef<string | null>(null);
  const prevRecordingsLength = useRef(recordings.length);

  // Find initial index
  const initialIndex = useMemo(
    () => recordings.findIndex((r) => r.documentId === initialId),
    [recordings, initialId],
  );

  // Handle not found case
  const isNotFound = recordings.length > 0 && initialIndex === -1;

  useEffect(() => {
    if (isNotFound && onNotFound) {
      onNotFound();
    }
  }, [isNotFound, onNotFound]);

  // When recordings change (new page loaded), maintain scroll position
  useLayoutEffect(() => {
    // If videos were prepended (previous page loaded)
    if (
      visibleDocumentId.current &&
      recordings.length > prevRecordingsLength.current
    ) {
      // Find where our current video is now
      const newIndex = recordings.findIndex(
        (r) => r.documentId === visibleDocumentId.current,
      );

      if (newIndex !== -1 && newIndex !== visibleIndex) {
        // Scroll to maintain position (instant, no animation)
        requestAnimationFrame(() => {
          const target = slideRefs.current.get(newIndex);
          target?.scrollIntoView({ behavior: "instant" });
        });
      }
    }

    prevRecordingsLength.current = recordings.length;
  }, [recordings, visibleIndex]);

  // Scroll to initial recording once when data loads
  useEffect(() => {
    if (hasScrolledToInitial.current) return;
    if (recordings.length === 0) return;
    if (initialIndex === -1) return;

    if (initialIndex === 0) {
      hasScrolledToInitial.current = true;
      visibleDocumentId.current = recordings[0]?.documentId || null;
      return;
    }

    requestAnimationFrame(() => {
      const target = slideRefs.current.get(initialIndex);
      target?.scrollIntoView({ behavior: "instant" });
    });

    hasScrolledToInitial.current = true;
    visibleDocumentId.current = recordings[initialIndex]?.documentId || null;
  }, [initialIndex, recordings]);

  const goToPrev = useCallback(() => {
    if (visibleIndex === null) return;

    if (visibleIndex > 0) {
      // There's a previous video in array, scroll to it
      const target = slideRefs.current.get(visibleIndex - 1);
      target?.scrollIntoView({ behavior: "smooth" });
    } else if (hasPreviousPage && !isFetchingPreviousPage) {
      // At start of array, fetch previous page
      // After it loads, useLayoutEffect will handle scroll position
      onFetchPreviousPage?.();
    }
  }, [
    visibleIndex,
    hasPreviousPage,
    isFetchingPreviousPage,
    onFetchPreviousPage,
  ]);

  const goToNext = useCallback(() => {
    if (visibleIndex === null) return;

    if (visibleIndex < recordings.length - 1) {
      const target = slideRefs.current.get(visibleIndex + 1);
      target?.scrollIntoView({ behavior: "smooth" });
    } else if (hasNextPage && !isFetchingNextPage) {
      // At end of array, fetch next page
      onFetchNextPage?.();
    }
  }, [
    visibleIndex,
    recordings.length,
    hasNextPage,
    isFetchingNextPage,
    onFetchNextPage,
  ]);

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
        e.preventDefault();
        goToPrev();
      } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        e.preventDefault();
        goToNext();
      } else if (e.key === "Escape" && onClose) {
        onClose();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [goToPrev, goToNext, onClose]);

  const handleVisibleChange = useCallback(
    (index: number) => {
      setVisibleIndex(index);

      const recording = recordings[index];
      if (!recording) return;

      // Track by documentId so we can find it after array changes
      visibleDocumentId.current = recording.documentId!;

      onVisibleChange?.(recording);

      // Prefetch next page when near end
      const isNearEnd = index >= recordings.length - 3;
      if (isNearEnd && hasNextPage && !isFetchingNextPage) {
        onFetchNextPage?.();
      }

      // Prefetch previous page when near start
      const isNearStart = index <= 2;
      if (isNearStart && hasPreviousPage && !isFetchingPreviousPage) {
        onFetchPreviousPage?.();
      }
    },
    [
      recordings,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
      onFetchNextPage,
      onFetchPreviousPage,
      onVisibleChange,
    ],
  );

  if (isLoading) {
    return (
      <Flex h={height} justify="center" align="center">
        <Loader size="lg" />
      </Flex>
    );
  }

  if (isNotFound) {
    return (
      <Flex h={height} justify="center" align="center">
        <Stack align="center" gap="md">
          <IconVideoOff size={64} stroke={1.5} color="gray" />
          <Text size="lg" c="dimmed">
            Recording not found
          </Text>
          {onClose && (
            <ActionIcon variant="light" size="lg" onClick={onClose}>
              <IconX />
            </ActionIcon>
          )}
        </Stack>
      </Flex>
    );
  }

  const safeInitialIndex = initialIndex === -1 ? 0 : initialIndex;

  // Show prev if there's a video before OR if there's a previous page to load
  const showPrev =
    visibleIndex !== null && (visibleIndex > 0 || hasPreviousPage);
  const showNext =
    visibleIndex !== null &&
    (visibleIndex < recordings.length - 1 || hasNextPage);

  return (
    <Box pos="relative" h={height}>
      {/* Close button */}
      {showCloseButton && onClose && (
        <ActionIcon
          variant="filled"
          radius="xl"
          size="input-md"
          bg="rgb(20 20 30 / 0.7)"
          color="gray"
          onClick={(e) => {
            e.stopPropagation();
            onClose();
          }}
          pos="absolute"
          top={20}
          left={20}
          style={{ zIndex: 100 }}
        >
          <IconX />
        </ActionIcon>
      )}

      {/* Navigation buttons */}
      <Group
        pos="absolute"
        right={20}
        top="50%"
        gap="xs"
        style={{
          transform: "translateY(-50%)",
          flexDirection: "column",
          zIndex: 100,
        }}
      >
        {showPrev && (
          <ActionIcon
            variant="filled"
            radius="xl"
            size="input-md"
            bg="rgb(20 20 30 / 0.7)"
            color="gray"
            onClick={goToPrev}
            loading={isFetchingPreviousPage}
          >
            <IconChevronUp />
          </ActionIcon>
        )}
        {showNext && (
          <ActionIcon
            variant="filled"
            radius="xl"
            size="input-md"
            bg="rgb(20 20 30 / 0.7)"
            color="gray"
            onClick={goToNext}
            loading={isFetchingNextPage}
          >
            <IconChevronDown />
          </ActionIcon>
        )}
      </Group>

      {/* Scroll container */}
      <Box
        ref={containerRef}
        h="100%"
        className="no-scrollbar"
        style={{
          overflowY: "auto",
          scrollSnapType: "y mandatory",
          scrollBehavior: "smooth",
          scrollbarWidth: "none",
          msOverflowStyle: "none",
          overscrollBehavior: "contain",
          position: "relative",
          zIndex: 1,
        }}
      >
        {recordings.map((recording, index) => (
          <VideoSlide
            key={recording.documentId}
            recording={recording}
            index={index}
            isInitiallyVisible={index === safeInitialIndex}
            onVisible={handleVisibleChange}
            registerRef={(el) => {
              if (el) slideRefs.current.set(index, el);
              else slideRefs.current.delete(index);
            }}
          />
        ))}
      </Box>
    </Box>
  );
}

// VideoSlide component stays the same
function VideoSlide({
  recording,
  index,
  isInitiallyVisible,
  onVisible,
  registerRef,
}: {
  recording: Recording;
  index: number;
  isInitiallyVisible: boolean;
  onVisible: (index: number) => void;
  registerRef: (el: HTMLDivElement | null) => void;
}) {
  const ref = useRef<HTMLDivElement>(null);
  const [isVisible, setIsVisible] = useState(isInitiallyVisible);
  const onVisibleRef = useRef(onVisible);

  useEffect(() => {
    onVisibleRef.current = onVisible;
  }, [onVisible]);

  useEffect(() => {
    registerRef(ref.current);
    return () => registerRef(null);
  }, [registerRef]);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsVisible(entry.isIntersecting);
        if (entry.isIntersecting) {
          onVisibleRef.current(index);
        }
      },
      { threshold: 0.5 },
    );

    observer.observe(element);
    return () => observer.disconnect();
  }, [index]);

  return (
    <Flex
      ref={ref}
      h="100%"
      justify="center"
      align="center"
      style={{
        scrollSnapAlign: "start",
        scrollSnapStop: "always",
      }}
    >
      {isVisible ? (
        <VideoPlayer recording={recording} key={recording.documentId} />
      ) : (
        <Box w="100%" h="100%" bg="dark.9" />
      )}
    </Flex>
  );
}
