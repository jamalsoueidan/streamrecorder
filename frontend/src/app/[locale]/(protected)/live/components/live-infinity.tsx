// app/(protected)/video/components/video-infinity.tsx
"use client";

import { FollowerTypeEnum } from "@/lib/types/strapi-autogenerated";
import {
  ActionIcon,
  Anchor,
  Avatar,
  Badge,
  Button,
  Divider,
  Grid,
  Group,
  Loader,
  SimpleGrid,
  Stack,
  Text,
  Title,
  Tooltip,
} from "@mantine/core";
import { useIntersection } from "@mantine/hooks";
import {
  IconPlayerRecord,
  IconPlayerRecordFilled,
  IconRefresh,
  IconVideo,
  IconWorldSearch,
} from "@tabler/icons-react";
import { useInfiniteQuery } from "@tanstack/react-query";
import { useFormatter, useNow, useTranslations } from "next-intl";
import Link from "next/link";
import { useEffect, useRef } from "react";

import { generateAvatarUrl } from "@/app/lib/avatar-url";
import { Role } from "@/app/providers/ability-provider";

import { getProfileUrl } from "@/app/components/open-social";
import { ImageVideoPreview } from "../../components/image-video-preview";
import { fetchLiveRecordings } from "../actions/fetch-live-recordings";

interface Props {
  scope: string;
}

export default function LiveInfinity({ scope }: Props) {
  const t = useTranslations("protected.live");
  const tc = useTranslations("protected.common");
  const format = useFormatter();
  const now = useNow({ updateInterval: 1000 * 30 });
  const isFetchingRef = useRef(false);

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    refetch,
  } = useInfiniteQuery({
    queryKey: ["live-recordings", scope],
    queryFn: ({ pageParam }) => fetchLiveRecordings(scope, pageParam),
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      const { page = 1, pageCount = 0 } = lastPage.meta?.pagination ?? {};
      return page < pageCount ? page + 1 : undefined;
    },
  });

  const { ref, entry } = useIntersection({
    threshold: 0.5,
  });

  // Sync ref with state
  useEffect(() => {
    isFetchingRef.current = isFetchingNextPage;
  }, [isFetchingNextPage]);

  // Load more when sentinel is visible
  useEffect(() => {
    if (entry?.isIntersecting && hasNextPage && !isFetchingRef.current) {
      isFetchingRef.current = true;
      fetchNextPage();
    }
  }, [entry?.isIntersecting, hasNextPage, fetchNextPage]);

  const recordings = data?.pages.flatMap((p) => p.data) ?? [];
  const total = data?.pages[0]?.meta?.pagination?.total ?? 0;

  if (isLoading) {
    return (
      <Stack align="center" py="xl">
        <Loader size="lg" />
      </Stack>
    );
  }

  if (recordings.length === 0) {
    return (
      <Stack align="center" justify="center" py={80} gap="lg">
        <ActionIcon variant="transparent" size={120} radius="xl" color="white">
          <IconVideo size={90} stroke={2} />
        </ActionIcon>
        <Stack align="center" gap={12}>
          <Title order={2} fw={600}>
            {t("emptyState.title")}
          </Title>
          <Text size="xl" c="dimmed" maw={450} ta="center">
            {t("emptyState.description")}
          </Text>
        </Stack>
        <Anchor href="/discover" underline="never">
          <Button
            size="lg"
            radius="md"
            leftSection={<IconWorldSearch size={20} />}
          >
            {t("discoverStreamers")}
          </Button>
        </Anchor>
      </Stack>
    );
  }

  return (
    <Stack gap="sm">
      <Group justify="space-between" align="flex-start">
        <Stack gap={2}>
          <Group gap="xs">
            <IconPlayerRecordFilled color="red" size="32px" />
            <Title order={1} size="h3">
              {t("title")}
            </Title>
            <Badge
              size="lg"
              color="red"
              variant="dot"
              styles={{
                root: {
                  animation: "pulse 2s infinite",
                },
              }}
            >
              {t("streamingCount", { count: total })}
            </Badge>
          </Group>
          <Text c="dimmed" size="sm">
            {t("subtitle")}
          </Text>
        </Stack>

        <Group gap="xs">
          <Tooltip label={t("refresh")}>
            <ActionIcon variant="subtle" size={50} onClick={() => refetch()}>
              <IconRefresh size={20} />
            </ActionIcon>
          </Tooltip>
          <Role is={["admin", "moderator"]}>
            <Button
              component={Link}
              color="yellow"
              variant="light"
              leftSection={<IconPlayerRecord size={18} />}
              size="lg"
              href={"?scope=all"}
            >
              {t("showAll")}
            </Button>
          </Role>
        </Group>
      </Group>

      <Divider />

      <SimpleGrid cols={{ base: 1, sm: 2, md: 3, xl: 4 }} spacing="lg">
        {recordings.map((rec) => (
          <Grid gutter="xs" key={rec.documentId} w="100%">
            {rec.follower && (
              <Grid.Col span={12}>
                <ImageVideoPreview
                  key={rec.documentId}
                  username={rec.follower?.username || "unknown"}
                  type={rec.follower?.type || FollowerTypeEnum.Tiktok}
                  recording={rec}
                />
              </Grid.Col>
            )}
            <Grid.Col span={12}>
              <Group gap="xs">
                <Anchor component={Link} href={getProfileUrl(rec.follower)}>
                  <Avatar
                    size={38}
                    src={generateAvatarUrl(rec.follower?.avatar?.url)}
                    styles={{
                      image: {
                        transform: "scale(2)",
                        objectFit: "cover",
                      },
                    }}
                  />
                </Anchor>

                <Stack gap="0">
                  <Anchor
                    component={Link}
                    href={getProfileUrl(rec.follower)}
                    size="md"
                    truncate
                    maw={110}
                    display="inline-block"
                  >
                    {rec.follower?.username}
                  </Anchor>
                  <Text size="xs" suppressHydrationWarning>
                    {tc("recordings.liveAgo", {
                      time: format.relativeTime(new Date(rec.updatedAt || ""), {
                        now,
                      }),
                    })}
                  </Text>
                </Stack>
              </Group>
            </Grid.Col>
          </Grid>
        ))}
      </SimpleGrid>

      {/* Sentinel for infinite scroll */}
      {hasNextPage && !isFetchingNextPage && (
        <div ref={ref} style={{ height: 20 }} />
      )}

      {isFetchingNextPage && (
        <Loader size="sm" style={{ alignSelf: "center" }} />
      )}
    </Stack>
  );
}
