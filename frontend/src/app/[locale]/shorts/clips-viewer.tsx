"use client";

import { getRandomClip } from "@/app/actions/clip";
import { Clip, Follower } from "@/lib/types/strapi-autogenerated";
import {
  ActionIcon,
  Avatar,
  Box,
  Card,
  Center,
  Flex,
  Loader,
  Stack,
  Text,
} from "@mantine/core";
import {
  IconChevronDown,
  IconChevronUp,
  IconPlayerPause,
  IconPlayerPlay,
} from "@tabler/icons-react";
import { useCallback, useEffect, useRef, useState, useTransition } from "react";
import "./clips-viewer.css";

interface ClipCardProps {
  clip: Clip & { follower: Follower | null };
  isActive: boolean;
}

function ClipCard({ clip, isActive }: ClipCardProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [isPlaying, setIsPlaying] = useState(false);

  // Control play/pause based on isActive
  useEffect(() => {
    if (!videoRef.current) return;

    if (isActive) {
      videoRef.current.play().catch(() => {});
    } else {
      videoRef.current.pause();
      videoRef.current.currentTime = 0;
    }
  }, [isActive]);

  // Listen to video events to track playing state
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const onPlay = () => setIsPlaying(true);
    const onPause = () => setIsPlaying(false);

    video.addEventListener("play", onPlay);
    video.addEventListener("pause", onPause);

    return () => {
      video.removeEventListener("play", onPlay);
      video.removeEventListener("pause", onPause);
    };
  }, []);

  const togglePlay = () => {
    if (!videoRef.current) return;
    if (isPlaying) {
      videoRef.current.pause();
    } else {
      videoRef.current.play();
    }
  };

  return (
    <Flex
      pos="relative"
      w="100%"
      h="100%"
      justify="center"
      style={{
        scrollSnapAlign: "start",
        scrollSnapStop: "always",
        flexShrink: 0,
        overflow: "hidden",
      }}
    >
      <Card pos="relative" maw={480} radius="lg" p="0" m="xs">
        <video
          ref={videoRef}
          src={`/clip/${clip.documentId}/clip.mp4`}
          loop
          playsInline
          preload={isActive ? "auto" : "metadata"}
          onClick={togglePlay}
          style={{
            width: "100%",
            height: "100%",
            objectFit: "contain",
            cursor: "pointer",
          }}
        >
          <track
            kind="subtitles"
            src={`/clip/${clip.documentId}/subtitles.vtt`}
            srcLang="en"
            label={"Subtitles"}
            default
          />
        </video>
      </Card>

      {/* Play/Pause overlay */}
      <Center
        pos="absolute"
        top={0}
        left={0}
        right={0}
        bottom={0}
        bg="rgba(0,0,0,0.3)"
        c="rgba(255,255,255,0.9)"
        style={{
          opacity: isPlaying ? 0 : 1,
          transition: "opacity 0.2s",
          pointerEvents: "none",
        }}
      >
        {isPlaying ? (
          <IconPlayerPause size={64} stroke={1.5} />
        ) : (
          <IconPlayerPlay size={64} stroke={1.5} />
        )}
      </Center>

      <Box
        pos="absolute"
        bottom={0}
        left={0}
        right={0}
        p="lg"
        pb="xl"
        style={{
          background:
            "linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%)",
        }}
      >
        <Stack gap="xs" align="center">
          <Avatar
            src={clip.follower?.avatar?.url || undefined}
            size={44}
            radius="xl"
            color="blue"
          >
            {clip.follower?.nickname?.[0]?.toUpperCase() || "?"}
          </Avatar>
          <Text fw={600} size="md" c="white" ta="center">
            {clip.follower?.nickname}
          </Text>
          {clip.title && (
            <Text size="sm" c="white" fw={500} ta="center">
              {clip.title}
            </Text>
          )}
        </Stack>
      </Box>
    </Flex>
  );
}

interface ClipsViewerProps {
  initialClips: Array<Clip & { follower: Follower | null }>;
}

export function ClipsViewer({ initialClips }: ClipsViewerProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [clips, setClips] =
    useState<Array<Clip & { follower: Follower | null }>>(initialClips);
  const [activeIndex, setActiveIndex] = useState(0);
  const [isPending, startTransition] = useTransition();
  const loadingRef = useRef(false);

  const prefetchNext = useCallback(async () => {
    if (loadingRef.current) return;
    loadingRef.current = true;

    startTransition(async () => {
      const newClip = await getRandomClip();
      if (newClip) {
        setClips((prev) => [...prev, newClip]);
      }
      loadingRef.current = false;
    });
  }, []);

  useEffect(() => {
    if (activeIndex >= clips.length - 2) {
      prefetchNext();
    }
  }, [activeIndex, clips.length, prefetchNext]);

  const scrollToIndex = useCallback(
    (index: number) => {
      if (!containerRef.current) return;
      const clampedIndex = Math.max(0, Math.min(index, clips.length - 1));
      const clipHeight = containerRef.current.clientHeight;
      containerRef.current.scrollTo({
        top: clampedIndex * clipHeight,
        behavior: "smooth",
      });
    },
    [clips.length],
  );

  const handleScroll = useCallback(() => {
    if (!containerRef.current) return;
    const { scrollTop, clientHeight } = containerRef.current;
    const newIndex = Math.round(scrollTop / clientHeight);
    if (newIndex !== activeIndex) {
      setActiveIndex(newIndex);
    }
  }, [activeIndex]);

  const goUp = useCallback(
    () => scrollToIndex(activeIndex - 1),
    [activeIndex, scrollToIndex],
  );
  const goDown = useCallback(
    () => scrollToIndex(activeIndex + 1),
    [activeIndex, scrollToIndex],
  );

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "ArrowUp") {
        e.preventDefault();
        goUp();
      } else if (e.key === "ArrowDown") {
        e.preventDefault();
        goDown();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [goDown, goUp]);

  return (
    <Box
      pos="relative"
      w="100%"
      h="calc(100dvh - 60px)"
      style={{ overflow: "hidden" }}
    >
      <Box
        ref={containerRef}
        onScroll={handleScroll}
        className="clips-container"
        w="100%"
        h="100%"
        style={{
          overflowY: "scroll",
          scrollSnapType: "y mandatory",
          scrollBehavior: "smooth",
          scrollbarWidth: "none",
          msOverflowStyle: "none",
        }}
      >
        {clips.map((clip, index) => (
          <ClipCard
            key={`${clip.id}-${index}`}
            clip={clip}
            isActive={index === activeIndex}
          />
        ))}

        {isPending && (
          <Center h={100} w="100%">
            <Loader color="white" size="sm" />
          </Center>
        )}
      </Box>

      {/* Navigation buttons */}
      <Stack
        pos="absolute"
        right={24}
        top="50%"
        gap="xs"
        style={{ transform: "translateY(-50%)", zIndex: 100 }}
      >
        <ActionIcon
          variant="filled"
          size={44}
          radius="xl"
          onClick={goUp}
          disabled={activeIndex === 0}
          bg="rgba(30,30,30,0.9)"
          c="white"
          style={{
            backdropFilter: "blur(10px)",
            border: "1px solid rgba(255,255,255,0.1)",
          }}
        >
          <IconChevronUp size={24} />
        </ActionIcon>
        <ActionIcon
          variant="filled"
          size={44}
          radius="xl"
          onClick={goDown}
          bg="rgba(30,30,30,0.9)"
          c="white"
          style={{
            backdropFilter: "blur(10px)",
            border: "1px solid rgba(255,255,255,0.1)",
          }}
        >
          <IconChevronDown size={24} />
        </ActionIcon>
      </Stack>
    </Box>
  );
}
