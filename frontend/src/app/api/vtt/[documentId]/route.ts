import { buildVideoRanges } from "@/app/(protected)/components/video/player-utils";
import publicApi from "@/lib/public-api";
import { Recording } from "@/lib/types/strapi-autogenerated";
import { NextRequest } from "next/server";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ documentId: string }> }
) {
  try {
    const { documentId } = await params;

    const response = await publicApi.recording.getRecordingsId({
      id: documentId,
      populate: {
        sources: {
          fields: ["*"],
          filters: {
            state: {
              $eq: "done",
            },
          },
          populate: ["videoSmall", "videoOriginal"], // we ask for original because sometime small is null while encoding for mini-player
        },
      },
    });

    if (!response?.data.data) {
      return new Response("Not found", { status: 404 });
    }

    const recording = response.data.data as unknown as Recording;

    const videoRanges = buildVideoRanges(recording.sources || []);

    if (!videoRanges.length) {
      return new Response("No thumbnails", { status: 404 });
    }

    const thumbWidth = 160;
    const thumbHeight = 284;
    let vtt = "WEBVTT\n\n";

    for (const range of videoRanges) {
      if (!range.path) continue;

      const spriteUrl = `${range.path}thumbnails.jpg`;
      const numThumbs = Math.ceil((range.end - range.start) / range.interval);

      for (let i = 0; i < numThumbs; i++) {
        const cueStart = range.start + i * range.interval;
        const cueEnd = Math.min(
          range.start + (i + 1) * range.interval,
          range.end
        );

        const col = i % range.cols;
        const row = Math.floor(i / range.cols);
        const x = col * thumbWidth;
        const y = row * thumbHeight;

        vtt += `${formatTime(cueStart)} --> ${formatTime(cueEnd)}\n`;
        vtt += `${spriteUrl}#xywh=${x},${y},${thumbWidth},${thumbHeight}\n\n`;
      }
    }

    return new Response(vtt, {
      headers: { "Content-Type": "text/vtt" },
    });
  } catch (error) {
    console.error("VTT error:", error);
    return new Response(`Error: ${error}`, { status: 500 });
  }
}

function formatTime(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${hrs.toString().padStart(2, "0")}:${mins
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")}.${ms
    .toString()
    .padStart(3, "0")}`;
}
