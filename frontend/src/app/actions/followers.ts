"use server";

import api from "@/lib/api";
import { getToken } from "@/lib/token";
import {
  FollowerTypeEnum,
  FollowRequestBody,
} from "@/lib/types/strapi-autogenerated";
import * as Sentry from "@sentry/nextjs";
import { revalidatePath } from "next/cache";

export async function follow(prevState: any, formData: FormData) {
  const username = formData.get("username") as string;
  const type = formData.get("type") as FollowerTypeEnum;

  try {
    await api.follower.followCreate({
      username,
      type,
    });

    revalidatePath("/following");

    return { success: true, username, type };
  } catch (err: any) {
    return { error: err.response?.data?.error?.message || "Failed to follow" };
  }
}

export async function followUser(data: FollowRequestBody) {
  try {
    await api.follower.followCreate(data);
    revalidatePath("/following");
    revalidatePath(`/${data.type}/${data.username}`);

    return { success: true };
  } catch (err: any) {
    return { error: err.response?.data?.error?.message || "Failed to follow" };
  }
}

export async function unfollow(data: FollowRequestBody) {
  try {
    await api.follower.unfollowCreate(data);
    revalidatePath("/following");
    revalidatePath(`/${data.type}/${data.username}`);

    return { success: true };
  } catch (err: any) {
    return {
      error: err.response?.data?.error?.message || "Failed to unfollow",
    };
  }
}

export async function updateFollower(documentId: string, data: any) {
  await api.follower.putFollowersId({ id: documentId }, { data });
}

export async function getFollowerFilters() {
  const token = await getToken();

  // Add auth context for debugging
  Sentry.setContext("auth_debug", {
    hasToken: !!token,
    tokenLength: token?.length || 0,
  });

  try {
    const { data: filtersData } = await api.follower.getFollowerFilters();

    return {
      genders: (filtersData.genders ?? [])
        .filter((g) => g.value)
        .map((g) => ({
          value: g.value || "",
          label: `${g.value} (${g.count})`,
        })),
      countryCodes: (filtersData.countryCodes ?? [])
        .filter((c) => c.value !== "-")
        .map((c) => ({
          value: c.value || "",
          label: `${c.value} (${c.count})`,
        })),
      types: (filtersData.types ?? []).map((l) => ({
        value: l.value || "",
        label: `${l.value} (${l.count})`,
      })),
      languageCodes: (filtersData.languageCodes ?? []).map((l) => ({
        value: l.value || "",
        label: `${l.value} (${l.count})`,
      })),
    };
  } catch (error: any) {
    // Capture detailed error context
    Sentry.setContext("api_error", {
      status: error.response?.status,
      hasAuthHeader: !!error.config?.headers?.Authorization,
    });
    throw error;
  }
}
