"use server";
import deepmerge from "deepmerge";

import { SortOptions } from "@/lib/types/filtering";
import {
  BrowseRecordingsParams,
  ScopeEnum,
} from "@/lib/types/strapi-autogenerated";
import api from "../../lib/api";

export async function getRecordings(
  options: BrowseRecordingsParams & {
    sort: SortOptions | string;
  }
) {
  const response = await api.recording.browseRecordings(
    deepmerge(
      {
        "pagination[pageSize]": 10,
        filters: {
          //filter out recording that have failed?
          sources: {
            state: {
              $eq: "done",
            },
          },
        },
        populate: {
          sources: {
            fields: ["*"],
            filters: {
              // filter out from source
              state: {
                $eq: "done",
              },
            },
            populate: ["videoSmall", "videoOriginal"], // we ask for original because sometime small is null while encoding for mini-player
          },
          follower: {
            fields: ["username", "type"],
            populate: {
              avatar: {
                fields: ["url"],
              },
            },
          },
        },
      },
      options
    )
  );

  return {
    data: response.data?.data || [],
    meta: response.data?.meta,
  };
}

export async function getRecordingsWithPrevNextByFollower({
  id,
}: {
  id: string;
}) {
  const response = await api.recording.getRecordingsId({
    id,
    populate: {
      sources: {
        fields: ["*"],
        populate: {
          videoOriginal: {
            fields: ["*"],
          },
        },
      },
      follower: {
        fields: ["username", "type"],
      },
    },
  });

  const recording = response.data.data;
  const currentCreatedAt = recording?.createdAt;
  const sources = recording?.sources || [];

  const [prevResponse, nextResponse] = await Promise.all([
    api.recording.getRecordings({
      filters: {
        follower: {
          username: { $eq: recording?.follower?.username },
          type: { $eq: recording?.follower?.type },
        },
        createdAt: { $gt: currentCreatedAt },
      },
      sort: SortOptions.createdAtDesc,
      "pagination[limit]": 1,
      fields: "documentId",
    }),

    api.recording.getRecordings({
      filters: {
        follower: {
          username: { $eq: recording?.follower?.username },
          type: { $eq: recording?.follower?.type },
        },
        createdAt: { $lt: currentCreatedAt },
      },
      sort: SortOptions.createdAtDesc,
      "pagination[limit]": 1,
      fields: "documentId",
    }),
  ]);

  return {
    sources,
    recording,
    prevId: prevResponse.data.data?.[0]?.documentId || null,
    nextId: nextResponse.data.data?.[0]?.documentId || null,
  };
}

interface GetRecordingOptions {
  id: string;
  sort: SortOptions | string;
}

export async function getRecordingsWithPrevNext({
  id,
  sort = SortOptions.createdAtDesc,
}: GetRecordingOptions) {
  const response = await api.recording.getRecordingsId({
    id,
    populate: {
      sources: {
        fields: ["*"],
        populate: {
          videoOriginal: {
            fields: ["*"],
          },
        },
      },
      follower: {
        fields: ["username", "type"],
      },
    },
  });

  const recording = response.data.data;
  const currentCreatedAt = recording?.createdAt;
  const sources = recording?.sources || [];

  const isDesc = sort.includes("desc");

  const [prevResponse, nextResponse] = await Promise.all([
    // Prev: opposite direction of list
    api.recording.browseRecordings({
      scope: ScopeEnum.Following,
      filters: {
        createdAt: isDesc
          ? { $gt: currentCreatedAt }
          : { $lt: currentCreatedAt },
      },
      sort,
      "pagination[limit]": 1,
      fields: "documentId",
    }),
    // Next: same direction as list
    api.recording.browseRecordings({
      scope: ScopeEnum.Following,
      filters: {
        createdAt: isDesc
          ? { $lt: currentCreatedAt }
          : { $gt: currentCreatedAt },
      },
      sort,
      "pagination[limit]": 1,
      fields: "documentId",
    }),
  ]);

  return {
    sources,
    recording,
    prevId: prevResponse.data.data?.[0]?.documentId || null,
    nextId: nextResponse.data.data?.[0]?.documentId || null,
  };
}
