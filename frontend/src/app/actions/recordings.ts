"use server";

import { ScopeEnum } from "@/lib/types/strapi-autogenerated";
import api from "../../lib/api";
import { SortOptions } from "../lib/types/filtering";

export async function getRecordings({
  scope,
  page,
  sort,
}: {
  scope: ScopeEnum;
  page: number;
  sort: SortOptions | string;
}) {
  const response = await api.recording.browseRecordings({
    scope,
    "pagination[page]": page,
    "pagination[pageSize]": 10,
    populate: {
      sources: {
        fields: ["id", "documentId", "path", "duration"],
      },
      follower: {
        fields: ["username", "type"],
      },
    },
    sort,
  });

  return {
    data: response.data?.data || [],
    meta: response.data?.meta,
  };
}

export async function getRecordingsWithPrevNextByFollower({
  id,
}: {
  id: string;
}) {
  const response = await api.recording.getRecordingsId({
    id,
    populate: "*",
  });

  const recording = response.data.data;
  const currentCreatedAt = recording?.createdAt;
  const sources = recording?.sources || [];

  const [prevResponse, nextResponse] = await Promise.all([
    api.recording.getRecordings({
      filters: {
        follower: {
          username: { $eq: recording?.follower?.username },
          type: { $eq: recording?.follower?.type },
        },
        createdAt: { $lt: currentCreatedAt },
      },
      sort: "createdAt:desc",
      "pagination[limit]": 1,
      fields: "documentId",
    }),

    api.recording.getRecordings({
      filters: {
        follower: {
          username: { $eq: recording?.follower?.username },
          type: { $eq: recording?.follower?.type },
        },
        createdAt: { $gt: currentCreatedAt },
      },
      sort: "createdAt:asc",
      "pagination[limit]": 1,
      fields: "documentId",
    }),
  ]);

  return {
    sources,
    recording,
    prevId: prevResponse.data.data?.[0]?.documentId || null,
    nextId: nextResponse.data.data?.[0]?.documentId || null,
  };
}

interface GetRecordingOptions {
  id: string;
  sort: SortOptions | string;
}

export async function getRecordingsWithPrevNext({
  id,
  sort = SortOptions.createdAtDesc,
}: GetRecordingOptions) {
  const response = await api.recording.getRecordingsId({
    id,
    populate: "*",
  });

  const recording = response.data.data;
  const currentCreatedAt = recording?.createdAt;
  const sources = recording?.sources || [];

  const isDesc = sort.includes("desc");
  console.log("isDesc:", isDesc);

  const [prevResponse, nextResponse] = await Promise.all([
    // Prev: opposite direction of list
    api.recording.browseRecordings({
      scope: ScopeEnum.Following,
      filters: {
        createdAt: isDesc
          ? { $gt: currentCreatedAt }
          : { $lt: currentCreatedAt },
      },
      sort: isDesc ? "createdAt:asc" : "createdAt:desc",
      "pagination[limit]": 1,
      fields: "documentId",
    }),
    // Next: same direction as list
    api.recording.browseRecordings({
      scope: ScopeEnum.Following,
      filters: {
        createdAt: isDesc
          ? { $lt: currentCreatedAt }
          : { $gt: currentCreatedAt },
      },
      sort: isDesc ? "createdAt:desc" : "createdAt:asc",
      "pagination[limit]": 1,
      fields: "documentId",
    }),
  ]);

  return {
    sources,
    recording,
    prevId: prevResponse.data.data?.[0]?.documentId || null,
    nextId: nextResponse.data.data?.[0]?.documentId || null,
  };
}
