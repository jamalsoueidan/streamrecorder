import publicApi from "@/lib/public-api";
import { Recording, Source } from "@/lib/types/strapi-autogenerated";
import { GetObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { NextRequest } from "next/server";

export type SourceWithPlaylist = Source & { playlist?: string | null };

const s3 = new S3Client({
  region: "fsn1",
  endpoint: "https://fsn1.your-objectstorage.com",
  credentials: {
    accessKeyId: process.env.S3_ACCESS_KEY!,
    secretAccessKey: process.env.S3_SECRET_KEY!,
  },
});

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ documentId: string }> },
) {
  const { documentId } = await params;
  const quality =
    request.nextUrl.searchParams.get("quality") === "small"
      ? "small"
      : "original";

  const response = await publicApi.recording.getRecordingsId({
    id: documentId.replace(/\.m3u8$/, ""),
    populate: {
      sources: {
        fields: ["path"],
        filters: {
          state: {
            $eq: "done",
          },
        },
      },
    },
  });

  if (!response?.data.data) {
    return new Response("Not found", { status: 404 });
  }

  const recording = response.data.data as unknown as Recording;
  const sources = recording.sources || [];

  // Fetch all playlists from S3
  const sourcesWithPlaylists = await fetchPlaylistsFromS3(sources, quality);

  const playlist = combinePlaylistsFromSources(sourcesWithPlaylists);

  return new Response(playlist, {
    headers: {
      "Content-Type": "application/vnd.apple.mpegurl",
      "Cache-Control": "public, max-age=31536000",
    },
  });
}

async function fetchFromS3(key: string): Promise<string | null> {
  try {
    const command = new GetObjectCommand({
      Bucket: process.env.MEDIA_BUCKET!,
      Key: key,
    });
    const response = await s3.send(command);
    return (await response.Body?.transformToString()) ?? null;
  } catch {
    return null;
  }
}

async function fetchPlaylistsFromS3(
  sources: Source[],
  quality: "original" | "small",
): Promise<SourceWithPlaylist[]> {
  const filename =
    quality === "original" ? "playlist.m3u8" : "playlist_small.m3u8";

  // Fetch all playlists in parallel
  const playlists = await Promise.all(
    sources.map((source) =>
      source.path
        ? fetchFromS3(`${source.path.substring(1)}${filename}`)
        : Promise.resolve(null),
    ),
  );

  // If requesting small and ANY failed, fallback to original for ALL
  if (quality === "small" && playlists.some((p) => p === null)) {
    const originalPlaylists = await Promise.all(
      sources.map((source) =>
        source.path
          ? fetchFromS3(`${source.path.substring(1)}playlist.m3u8`)
          : Promise.resolve(null),
      ),
    );
    return sources.map((source, i) => ({
      ...source,
      playlist: originalPlaylists[i],
    }));
  }

  return sources.map((source, i) => ({
    ...source,
    playlist: playlists[i],
  }));
}

export function combinePlaylistsFromSources(
  sources: SourceWithPlaylist[],
): string {
  if (!sources || sources.length === 0) return "";

  let combined = "#EXTM3U\n#EXT-X-VERSION:7\n";
  let maxDuration = 0;
  let isFirst = true;

  // Reverse to go from oldest to newest
  for (const source of [...sources].reverse()) {
    const playlist = source.playlist;

    if (!playlist) continue;

    const lines = playlist.split("\n");

    for (const line of lines) {
      if (line.startsWith("#EXTM3U")) continue;
      if (line.startsWith("#EXT-X-VERSION")) continue;
      if (line.startsWith("#EXT-X-MEDIA-SEQUENCE")) continue;
      if (line.startsWith("#EXT-X-ENDLIST")) continue;

      if (line.startsWith("#EXT-X-TARGETDURATION")) {
        const dur = parseInt(line.split(":")[1]);
        if (dur > maxDuration) maxDuration = dur;
        continue;
      }

      const baseUrl =
        typeof window !== "undefined" ? window.location.origin : "";

      if (line.startsWith("#EXT-X-MAP")) {
        if (!isFirst) {
          combined += "#EXT-X-DISCONTINUITY\n";
        }
        isFirst = false;
        combined +=
          line.replace(
            /URI="([^"]+)"/,
            `URI="${baseUrl}/media${source.path}$1"`,
          ) + "\n";
        continue;
      }

      if (line.includes(".mp4")) {
        combined +=
          line.replace(/(\S+\.mp4)/g, `${baseUrl}/media${source.path}$1`) +
          "\n";
      } else if (line.trim()) {
        combined += line + "\n";
      }
    }
  }

  combined = combined.replace(
    "#EXT-X-VERSION:7\n",
    `#EXT-X-VERSION:7\n#EXT-X-TARGETDURATION:${maxDuration || 12}\n`,
  );

  combined += "#EXT-X-ENDLIST\n";
  return combined;
}

export function formatDuration(totalSeconds: number): string {
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = Math.floor(totalSeconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${seconds
      .toString()
      .padStart(2, "0")}`;
  }
  return `${minutes}:${seconds.toString().padStart(2, "0")}`;
}

export function buildVideoRanges(sources: Source[]) {
  const ranges: {
    start: number;
    end: number;
    path: string;
    interval: number;
    cols: number;
  }[] = [];

  const baseUrl = typeof window !== "undefined" ? window.location.origin : "";

  let cumTime = 0;
  for (const source of [...sources].reverse()) {
    const dur = source.duration || 0;
    ranges.push({
      start: cumTime,
      end: cumTime + dur,
      path: baseUrl + "/media" + source.path || "",
      interval: source.thumbnailInterval || 10,
      cols: source.thumbnailCols || 10,
    });
    cumTime += dur;
  }

  return ranges;
}
