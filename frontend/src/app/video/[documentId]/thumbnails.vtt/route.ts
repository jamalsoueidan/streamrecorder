import publicApi from "@/lib/public-api";
import { Recording, Source } from "@/lib/types/strapi-autogenerated";
import { NextRequest } from "next/server";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ documentId: string }> },
) {
  const { documentId } = await params;

  const response = await publicApi.recording.getRecordingsId({
    id: documentId.replace(/\.vtt$/, ""),
    populate: {
      sources: {
        fields: ["path", "duration", "thumbnailInterval", "thumbnailCols"],
        filters: {
          state: {
            $eq: "done",
          },
        },
      },
    },
  });

  if (!response?.data.data) {
    return new Response("Not found", { status: 404 });
  }

  const recording = response.data.data as unknown as Recording;
  const sources = recording.sources || [];

  const vtt = generateVTT(sources);

  return new Response(vtt, {
    headers: {
      "Content-Type": "text/vtt",
      "Cache-Control": "public, max-age=31536000",
    },
  });
}

function generateVTT(sources: Source[]): string {
  const videoRanges = buildVideoRanges(sources);

  if (!videoRanges.length) {
    return "WEBVTT\n";
  }

  const thumbWidth = 160;
  const thumbHeight = 284;
  let vtt = "WEBVTT\n\n";

  for (const range of videoRanges) {
    if (!range.path) continue;

    const spriteUrl = `${range.path}thumbnails.jpg`;
    const numThumbs = Math.ceil((range.end - range.start) / range.interval);

    for (let i = 0; i < numThumbs; i++) {
      const cueStart = range.start + i * range.interval;
      const cueEnd = Math.min(
        range.start + (i + 1) * range.interval,
        range.end,
      );

      const col = i % range.cols;
      const row = Math.floor(i / range.cols);
      const x = col * thumbWidth;
      const y = row * thumbHeight;

      vtt += `${formatVTTTime(cueStart)} --> ${formatVTTTime(cueEnd)}\n`;
      vtt += `${spriteUrl}#xywh=${x},${y},${thumbWidth},${thumbHeight}\n\n`;
    }
  }

  return vtt;
}

function buildVideoRanges(sources: Source[]) {
  const ranges: {
    start: number;
    end: number;
    path: string;
    interval: number;
    cols: number;
  }[] = [];

  let cumTime = 0;
  for (const source of [...sources].reverse()) {
    const dur = source.duration || 0;
    ranges.push({
      start: cumTime,
      end: cumTime + dur,
      path: "/media" + source.path || "",
      interval: source.thumbnailInterval || 10,
      cols: source.thumbnailCols || 10,
    });
    cumTime += dur;
  }

  return ranges;
}

function formatVTTTime(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${hrs.toString().padStart(2, "0")}:${mins
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")}.${ms
    .toString()
    .padStart(3, "0")}`;
}
