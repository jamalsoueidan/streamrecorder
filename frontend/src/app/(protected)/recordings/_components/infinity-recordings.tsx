// components/infinite-followers.tsx
"use client";

import { getRecordings } from "@/app/actions/recordings";

import dayjs from "@/app/lib/dayjs";
import { SortOptions } from "@/lib/types/filtering";
import {
  RecordingListResponse,
  ScopeEnum,
} from "@/lib/types/strapi-autogenerated";
import {
  Anchor,
  Avatar,
  Divider,
  Flex,
  Grid,
  Group,
  Loader,
  Select,
  Stack,
  Text,
  Title,
} from "@mantine/core";
import { useIntersection } from "@mantine/hooks";
import Link from "next/link";
import { parseAsStringEnum, useQueryState } from "nuqs";
import { useEffect, useRef, useState, useTransition } from "react";
import { ImageVideoPreview } from "./image-video-preview";

const SORT_OPTIONS = [
  { value: SortOptions.createdAtDesc, label: "Newest first" },
  { value: SortOptions.createdAtAsc, label: "Oldest first" },
];

interface Props {
  initialData: RecordingListResponse["data"];
  initialPagination: RecordingListResponse["meta"];
  initialSort?: SortOptions;
}

export default function InfiniteRecordings({
  initialData,
  initialPagination,
  initialSort,
}: Props) {
  const [data, setData] = useState(initialData);
  const [page, setPage] = useState(initialPagination?.pagination?.page ?? 1);
  const [hasMore, setHasMore] = useState(
    page < (initialPagination?.pagination?.pageCount ?? 1)
  );
  const [sort, setSort] = useQueryState(
    "sort",
    parseAsStringEnum<SortOptions>(Object.values(SortOptions)).withDefault(
      initialSort || SortOptions.createdAtDesc
    )
  );

  const [isPending, startTransition] = useTransition();

  const { ref, entry } = useIntersection({
    threshold: 0.5,
  });

  const handleSortChange = (value: string | null) => {
    if (!value) return;
    setSort(value as unknown as SortOptions);
  };

  const isFirstRender = useRef(true);

  // 1. Refetch when sort changes
  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    startTransition(async () => {
      const result = await getRecordings({
        scope: ScopeEnum.Following,
        page: 1,
        sort,
      });
      setData(result.data);
      setPage(1);
      setHasMore(1 < (result.meta?.pagination?.pageCount ?? 1));
    });
  }, [sort]);

  useEffect(() => {
    if (entry?.isIntersecting && hasMore && !isPending) {
      startTransition(async () => {
        const nextPage = page + 1;
        const result = await getRecordings({
          scope: ScopeEnum.Following,
          page: nextPage,
          sort,
        });

        setData((prev) => {
          const existingIds = new Set(prev?.map((f) => f.id));
          const newItems = result.data.filter((f) => !existingIds.has(f.id));
          return [...(prev || []), ...newItems];
        });
        setPage(nextPage);
        setHasMore(nextPage < (result.meta?.pagination?.pageCount ?? 1));
      });
    }
  }, [entry?.isIntersecting, hasMore, isPending, page, sort]);

  return (
    <Stack gap="sm">
      <Group justify="space-between">
        <Title order={1} size="lg">
          Recordings ({initialPagination?.pagination?.total || 0})
        </Title>

        <Select
          key={sort}
          size="xs"
          w={180}
          value={sort}
          onChange={handleSortChange}
          data={SORT_OPTIONS}
          disabled={isPending}
        />
      </Group>
      <Divider />
      <Flex gap="lg" wrap="wrap">
        {(data || []).map((f) => (
          <Grid gutter="xs" key={f.documentId} w="160">
            <Grid.Col span={12}>
              <ImageVideoPreview
                key={f.documentId}
                href={`/${f.follower?.type}/${f.follower?.username}/live/${
                  f.documentId
                }${sort ? `?sort=` + sort : null}`}
                src={
                  f.sources?.length
                    ? process.env.NEXT_PUBLIC_S3_URL! +
                      f.sources[0].path +
                      "preview.jpg"
                    : null
                }
                w={160}
                h={284}
                sources={f.sources}
              />
            </Grid.Col>
            <Grid.Col span={12}>
              <Group gap="xs">
                <Anchor
                  component={Link}
                  href={`/${f.follower?.type}/${f.follower?.username}`}
                >
                  <Avatar
                    size={34}
                    src={
                      f.sources?.at(0)?.path
                        ? process.env.NEXT_PUBLIC_S3_URL! +
                          f.sources?.at(0)?.path +
                          "preview.jpg"
                        : null
                    }
                    styles={{
                      image: {
                        transform: "scale(2)",
                        objectFit: "cover",
                      },
                    }}
                  />
                </Anchor>

                <div>
                  <Anchor
                    component={Link}
                    href={`/${f.follower?.type}/${f.follower?.username}`}
                    size="md"
                    truncate
                    maw={120}
                  >
                    {f.follower?.username}
                  </Anchor>
                  <Text size="xs">live {dayjs(f.createdAt).fromNow()}</Text>
                </div>
              </Group>
            </Grid.Col>
          </Grid>
        ))}
      </Flex>
      {/* Sentinel element */}
      <div ref={ref} style={{ height: 1 }} />

      {isPending && <Loader size="sm" style={{ alignSelf: "center" }} />}

      {!hasMore && data && data.length > 0 && (
        <p style={{ textAlign: "center", color: "gray" }}>No more to load</p>
      )}
    </Stack>
  );
}
