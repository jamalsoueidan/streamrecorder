"use client";

import dayjs from "@/app/lib/dayjs";
import api from "@/lib/api";
import {
  BrowseRecordingsData,
  FollowerTypeEnum,
  RecordingListResponse,
} from "@/lib/types/strapi-autogenerated";
import {
  Anchor,
  Avatar,
  Grid,
  Group,
  Loader,
  SimpleGrid,
  Stack,
  Text,
} from "@mantine/core";
import { useIntersection } from "@mantine/hooks";
import Link from "next/link";
import { useCallback, useEffect, useState, useTransition } from "react";
import { ImageVideoPreview } from "../../components/image-video-preview";

interface Props {
  initialData: RecordingListResponse["data"];
  initialPagination: RecordingListResponse["meta"];
  fetchAction: (
    options: Parameters<typeof api.recording.browseRecordings>[0]
  ) => Promise<BrowseRecordingsData>;
}

export default function LiveInfinity({
  initialData,
  initialPagination,
  fetchAction,
}: Props) {
  const [data, setData] = useState(initialData);
  const [page, setPage] = useState(initialPagination?.pagination?.page ?? 1);
  const [hasMore, setHasMore] = useState(
    page < (initialPagination?.pagination?.pageCount ?? 1)
  );

  const [isPending, startTransition] = useTransition();

  const { ref, entry } = useIntersection({
    threshold: 0.5,
  });

  const loadMore = useCallback(() => {
    if (!hasMore || isPending) return;

    startTransition(async () => {
      const nextPage = page + 1;
      const result = await fetchAction({
        "pagination[page]": nextPage,
      });

      setData((prev) => {
        const existingIds = new Set(prev?.map((f) => f.id));
        const newItems =
          result?.data?.filter((f) => !existingIds.has(f.id)) || [];
        return [...(prev || []), ...newItems];
      });
      setPage(nextPage);
      setHasMore(nextPage < (result.meta?.pagination?.pageCount ?? 1));
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [hasMore, isPending, page]);

  useEffect(() => {
    if (entry?.isIntersecting) {
      loadMore();
    }
  }, [entry?.isIntersecting, loadMore]);

  return (
    <>
      <SimpleGrid cols={{ base: 1, sm: 2, md: 3, xl: 4 }} spacing="lg">
        {(data || []).map((rec) => {
          return (
            <Grid gutter="xs" key={rec.documentId} w="100%">
              {rec.follower ? (
                <Grid.Col span={12}>
                  <ImageVideoPreview
                    key={rec.documentId}
                    username={rec.follower?.username || "unknown"}
                    type={rec.follower?.type || FollowerTypeEnum.Tiktok}
                    recording={rec}
                  />
                </Grid.Col>
              ) : null}
              <Grid.Col span={12}>
                <Group gap="xs">
                  <Anchor
                    component={Link}
                    href={`/${rec.follower?.type}/${rec.follower?.username}`}
                  >
                    <Avatar
                      size={38}
                      src={rec.follower?.avatar?.url}
                      styles={{
                        image: {
                          transform: "scale(2)",
                          objectFit: "cover",
                        },
                      }}
                    />
                  </Anchor>

                  <Stack gap="0">
                    <Anchor
                      component={Link}
                      href={`/${rec.follower?.type}/${rec.follower?.username}`}
                      size="md"
                      truncate
                      maw={110}
                      display="inline-block"
                    >
                      {rec.follower?.username}
                    </Anchor>
                    <Text size="xs">live {dayjs(rec.updatedAt).fromNow()}</Text>
                  </Stack>
                </Group>
              </Grid.Col>
            </Grid>
          );
        })}
      </SimpleGrid>

      <div ref={ref} style={{ height: 20 }} />

      {isPending && <Loader size="sm" style={{ alignSelf: "center" }} />}
    </>
  );
}
