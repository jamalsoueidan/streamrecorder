"use client";

import { Recording } from "@/lib/types/strapi-autogenerated";
import "hls-video-element";
import "media-chrome";
import { useSearchParams } from "next/navigation";
import { useEffect, useMemo, useRef } from "react";
import {
  HlsVideo,
  MediaControlBar,
  MediaController,
  MediaLoadingIndicator,
  MediaMuteButton,
  MediaPosterImage,
  MediaSeekForwardButton,
  MediaTimeDisplay,
  MediaTimeRange,
  MediaVolumeRange,
} from "./media-chrome";
import { buildVideoRanges, combinePlaylistsFromSources } from "./player-utils";

export function VideoPlayer({ recording }: { recording: Recording }) {
  const searchParams = useSearchParams();
  const startTime = Number(searchParams.get("t")) || 0;

  const controllerRef = useRef<HTMLElement>(null);
  const videoRef = useRef<HTMLVideoElement>(null);

  const sources = useMemo(() => recording.sources ?? [], [recording.sources]);
  const videoRanges = useMemo(() => buildVideoRanges(sources), [sources]);

  const previewUrl = useMemo(() => {
    if (sources.length === 0) return null;
    return `${process.env.NEXT_PUBLIC_S3_URL}${
      sources[sources.length - 1].path
    }screenshot.jpg`;
  }, [sources]);

  const vttDataUrl = useMemo(() => {
    if (!videoRanges.length) return null;

    const thumbWidth = 160;
    const thumbHeight = 284;
    let vtt = "WEBVTT\n\n";

    for (const range of videoRanges) {
      if (!range.path) continue;

      const spriteUrl = `${process.env.NEXT_PUBLIC_S3_URL}${range.path}thumbnails.jpg`;
      const numThumbs = Math.ceil((range.end - range.start) / range.interval);

      for (let i = 0; i < numThumbs; i++) {
        const cueStart = range.start + i * range.interval;
        const cueEnd = Math.min(
          range.start + (i + 1) * range.interval,
          range.end
        );

        const col = i % range.cols;
        const row = Math.floor(i / range.cols);
        const x = col * thumbWidth;
        const y = row * thumbHeight;

        vtt += `${formatTime(cueStart)} --> ${formatTime(cueEnd)}\n`;
        vtt += `${spriteUrl}#xywh=${x},${y},${thumbWidth},${thumbHeight}\n\n`;
      }
    }

    return `data:text/vtt;charset=utf-8,${encodeURIComponent(vtt)}`;
  }, [videoRanges]);

  const playlistDataUrl = useMemo(() => {
    if (!sources?.length) return null;
    const playlist = combinePlaylistsFromSources(sources, "original");
    if (!playlist) return null;
    return `data:application/vnd.apple.mpegurl;charset=utf-8,${encodeURIComponent(
      playlist
    )}`;
  }, [sources]);

  // Handle seek and autoplay
  useEffect(() => {
    const video = videoRef.current as any;
    if (!video) return;

    const handleLoaded = () => {
      if (startTime > 0) {
        video.currentTime = startTime;
      } else {
        video.play().catch(() => {});
      }
    };

    const handleSeeked = () => {
      video.play().catch(() => {});
    };

    video.addEventListener("loadedmetadata", handleLoaded, { once: true });
    video.addEventListener("seeked", handleSeeked, { once: true });

    return () => {
      video.removeEventListener("loadedmetadata", handleLoaded);
      video.removeEventListener("seeked", handleSeeked);
    };
  }, [startTime]);

  const handleDoubleClick = () => {
    const controller = controllerRef.current;
    if (!controller) return;

    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      controller.requestFullscreen();
    }
  };

  if (!playlistDataUrl) return null;

  return (
    <>
      <MediaController
        ref={controllerRef}
        onDoubleClick={handleDoubleClick}
        style={{
          width: "100%",
          height: "100%",
          background: "#000",
        }}
      >
        <HlsVideo
          ref={videoRef}
          src={playlistDataUrl}
          slot="media"
          crossOrigin="anonymous"
          playsInline
        >
          {vttDataUrl && (
            <track
              default
              kind="metadata"
              label="thumbnails"
              src={vttDataUrl}
            />
          )}
        </HlsVideo>

        {previewUrl && <MediaPosterImage slot="poster" src={previewUrl} />}

        <MediaLoadingIndicator
          slot="centered-chrome"
          loadingdelay="0"
          style={{
            "--media-loading-indicator-transition-delay": "0ms",
          }}
        />

        <MediaControlBar>
          <MediaTimeRange />
          <MediaTimeDisplay showduration />
          <MediaSeekForwardButton seekoffset="10" />

          <div className="volume-hover-container">
            <MediaVolumeRange />
            <MediaMuteButton title="" />
          </div>
        </MediaControlBar>
      </MediaController>
    </>
  );
}

function formatTime(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${hrs.toString().padStart(2, "0")}:${mins
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")}.${ms
    .toString()
    .padStart(3, "0")}`;
}
