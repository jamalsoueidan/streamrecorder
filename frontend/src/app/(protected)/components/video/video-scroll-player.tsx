// app/(protected)/components/video-scroll-player.tsx
"use client";

import { Recording } from "@/lib/types/strapi-autogenerated";
import {
  ActionIcon,
  Box,
  Flex,
  Group,
  Loader,
  Stack,
  Text,
} from "@mantine/core";
import {
  IconChevronDown,
  IconChevronUp,
  IconVideoOff,
  IconX,
} from "@tabler/icons-react";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { VideoPlayer } from "./video-player";

interface VideoScrollPlayerProps {
  recordings: Recording[];
  initialId: string;
  isLoading?: boolean;
  hasNextPage?: boolean;
  isFetchingNextPage?: boolean;
  onFetchNextPage?: () => void;
  onVisibleChange?: (recording: Recording) => void;
  onClose?: () => void;
  onNotFound?: () => void;
  showCloseButton?: boolean;
  height?: string;
}

export function VideoScrollPlayer({
  recordings,
  initialId,
  isLoading,
  hasNextPage,
  isFetchingNextPage,
  onFetchNextPage,
  onVisibleChange,
  onClose,
  onNotFound,
  showCloseButton = true,
  height = "100dvh",
}: VideoScrollPlayerProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const slideRefs = useRef<Map<number, HTMLDivElement>>(new Map());
  const [visibleIndex, setVisibleIndex] = useState<number | null>(null);
  const hasScrolledToInitial = useRef(false);

  // Find initial index - returns -1 if not found
  const initialIndex = useMemo(
    () => recordings.findIndex((r) => r.documentId === initialId),
    [recordings, initialId]
  );

  // Handle not found case
  const isNotFound = recordings.length > 0 && initialIndex === -1;

  useEffect(() => {
    if (isNotFound && onNotFound) {
      onNotFound();
    }
  }, [isNotFound, onNotFound]);

  // Scroll to initial recording once when data loads
  useEffect(() => {
    // Already scrolled
    if (hasScrolledToInitial.current) return;

    // No data yet
    if (recordings.length === 0) return;

    // Recording not found - don't scroll, let not found handler deal with it
    if (initialIndex === -1) return;

    // Index 0 is already visible, no scroll needed - just mark as done
    if (initialIndex === 0) {
      hasScrolledToInitial.current = true;
      return;
    }

    // Scroll to the initial recording
    requestAnimationFrame(() => {
      const target = slideRefs.current.get(initialIndex);
      target?.scrollIntoView({ behavior: "instant" });
    });

    hasScrolledToInitial.current = true;
  }, [initialIndex, recordings.length]);

  const goToPrev = useCallback(() => {
    if (visibleIndex !== null && visibleIndex > 0) {
      const target = slideRefs.current.get(visibleIndex - 1);
      target?.scrollIntoView({ behavior: "smooth" });
    }
  }, [visibleIndex]);

  const goToNext = useCallback(() => {
    if (visibleIndex !== null && visibleIndex < recordings.length - 1) {
      const target = slideRefs.current.get(visibleIndex + 1);
      target?.scrollIntoView({ behavior: "smooth" });
    }
  }, [visibleIndex, recordings.length]);

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
        e.preventDefault();
        goToPrev();
      } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        e.preventDefault();
        goToNext();
      } else if (e.key === "Escape" && onClose) {
        onClose();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [goToPrev, goToNext, onClose]);

  const handleVisibleChange = useCallback(
    (index: number) => {
      setVisibleIndex(index);

      const recording = recordings[index];
      if (!recording) return;

      onVisibleChange?.(recording);

      // Prefetch next page when near end
      const isNearEnd = index >= recordings.length - 3;
      if (isNearEnd && hasNextPage && !isFetchingNextPage) {
        onFetchNextPage?.();
      }
    },
    [
      recordings,
      hasNextPage,
      isFetchingNextPage,
      onFetchNextPage,
      onVisibleChange,
    ]
  );

  if (isLoading) {
    return (
      <Flex h={height} justify="center" align="center">
        <Loader size="lg" />
      </Flex>
    );
  }

  // Show not found state
  if (isNotFound) {
    return (
      <Flex h={height} justify="center" align="center">
        <Stack align="center" gap="md">
          <IconVideoOff size={64} stroke={1.5} color="gray" />
          <Text size="lg" c="dimmed">
            Recording not found
          </Text>
          {onClose && (
            <ActionIcon variant="light" size="lg" onClick={onClose}>
              <IconX />
            </ActionIcon>
          )}
        </Stack>
      </Flex>
    );
  }

  // Safe initial index for isInitiallyVisible (use 0 as fallback)
  const safeInitialIndex = initialIndex === -1 ? 0 : initialIndex;

  const showPrev = visibleIndex !== null && visibleIndex > 0;
  const showNext =
    visibleIndex !== null &&
    (visibleIndex < recordings.length - 1 || hasNextPage);

  return (
    <Box pos="relative" h={height}>
      {/* Close button - top left */}
      {showCloseButton && onClose && (
        <ActionIcon
          variant="filled"
          radius="xl"
          size="xl"
          color="gray"
          onClick={(e) => {
            e.stopPropagation();
            onClose();
          }}
          pos="absolute"
          opacity={0.5}
          top={20}
          left={20}
          style={{ zIndex: 100 }} // Higher z-index
        >
          <IconX />
        </ActionIcon>
      )}

      {/* Navigation buttons - right side */}
      <Group
        pos="absolute"
        right={20}
        top="50%"
        gap="xs"
        style={{
          transform: "translateY(-50%)",
          flexDirection: "column",
          zIndex: 100, // Higher z-index
        }}
      >
        {showPrev && (
          <ActionIcon
            variant="filled"
            radius="xl"
            size="xl"
            color="gray"
            onClick={goToPrev}
            opacity={0.7}
          >
            <IconChevronUp />
          </ActionIcon>
        )}
        {showNext && (
          <ActionIcon
            variant="filled"
            radius="xl"
            size="xl"
            color="gray"
            onClick={goToNext}
            opacity={0.7}
            loading={isFetchingNextPage}
          >
            <IconChevronDown />
          </ActionIcon>
        )}
      </Group>

      {/* Scroll container with snap - lower z-index */}
      <Box
        ref={containerRef}
        h="100%"
        className="no-scrollbar"
        style={{
          overflowY: "auto",
          scrollSnapType: "y mandatory",
          scrollBehavior: "smooth",
          scrollbarWidth: "none",
          msOverflowStyle: "none",
          overscrollBehavior: "contain",
          position: "relative", // Add this
          zIndex: 1, // Add this - keeps it below buttons
        }}
      >
        {recordings.map((recording, index) => (
          <VideoSlide
            key={recording.documentId}
            recording={recording}
            index={index}
            isInitiallyVisible={index === safeInitialIndex}
            onVisible={handleVisibleChange}
            registerRef={(el) => {
              if (el) slideRefs.current.set(index, el);
              else slideRefs.current.delete(index);
            }}
          />
        ))}
      </Box>
    </Box>
  );
}

function VideoSlide({
  recording,
  index,
  isInitiallyVisible,
  onVisible,
  registerRef,
}: {
  recording: Recording;
  index: number;
  isInitiallyVisible: boolean;
  onVisible: (index: number) => void;
  registerRef: (el: HTMLDivElement | null) => void;
}) {
  const ref = useRef<HTMLDivElement>(null);
  const [isVisible, setIsVisible] = useState(isInitiallyVisible);

  useEffect(() => {
    registerRef(ref.current);
    return () => registerRef(null);
  }, [registerRef]);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsVisible(entry.isIntersecting);
        if (entry.isIntersecting) {
          onVisible(index);
        }
      },
      { threshold: 0.5 }
    );

    observer.observe(element);
    return () => observer.disconnect();
  }, [index, onVisible]);

  return (
    <Flex
      ref={ref}
      h="100%"
      justify="center"
      align="center"
      style={{
        scrollSnapAlign: "start",
        scrollSnapStop: "always",
      }}
    >
      {isVisible ? (
        <VideoPlayer recording={recording} key={recording.documentId} />
      ) : (
        <Box w="100%" h="100%" bg="dark.9" />
      )}
    </Flex>
  );
}
