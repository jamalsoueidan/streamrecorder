"use client";

import dayjs from "@/app/lib/dayjs";
import api from "@/lib/api";
import { SortOptions } from "@/lib/types/filtering";
import {
  BrowseRecordingsData,
  FollowerTypeEnum,
  RecordingListResponse,
} from "@/lib/types/strapi-autogenerated";
import {
  Anchor,
  Avatar,
  Button,
  Divider,
  Drawer,
  Grid,
  Group,
  Indicator,
  Loader,
  Select,
  SimpleGrid,
  Stack,
  Text,
  Title,
} from "@mantine/core";
import { useDisclosure, useIntersection } from "@mantine/hooks";
import { IconFilter } from "@tabler/icons-react";
import Link from "next/link";
import { parseAsString, parseAsStringEnum, useQueryStates } from "nuqs";
import { useCallback, useEffect, useState, useTransition } from "react";
import { ImageVideoPreview } from "../../_components/image-video-preview";

const SORT_OPTIONS = [
  { value: SortOptions.createdAtDesc, label: "Newest first" },
  { value: SortOptions.createdAtAsc, label: "Oldest first" },
];

interface FilterOptions {
  genders: { value: string; label: string }[];
  countries: { value: string; label: string }[];
  languages: { value: string; label: string }[];
}

interface Props {
  initialData: RecordingListResponse["data"];
  initialPagination: RecordingListResponse["meta"];
  initialSort?: SortOptions;
  filterOptions: FilterOptions;
  fetchAction: (
    options: Parameters<typeof api.recording.browseRecordings>[0]
  ) => Promise<BrowseRecordingsData>;
}

export default function FollowingInfinity({
  initialData,
  initialPagination,
  initialSort,
  filterOptions,
  fetchAction,
}: Props) {
  const [data, setData] = useState(initialData);
  const [page, setPage] = useState(initialPagination?.pagination?.page ?? 1);
  const [hasMore, setHasMore] = useState(
    page < (initialPagination?.pagination?.pageCount ?? 1)
  );

  const [filters, setFilters] = useQueryStates({
    sort: parseAsStringEnum<SortOptions>(
      Object.values(SortOptions)
    ).withDefault(initialSort || SortOptions.createdAtDesc),
    gender: parseAsString,
    country: parseAsString,
    language: parseAsString,
  });

  const [isPending, startTransition] = useTransition();
  const [opened, { open, close }] = useDisclosure(false);
  const { ref, entry } = useIntersection({ threshold: 0.5 });

  const activeFilterCount = [
    filters.gender,
    filters.country,
    filters.language,
  ].filter(Boolean).length;

  const getFilterParams = useCallback(() => {
    const params: Record<string, any> = {};
    if (filters.gender) params["filters[gender][$eq]"] = filters.gender;
    if (filters.country) params["filters[country][$eq]"] = filters.country;
    if (filters.language) params["filters[language][$eq]"] = filters.language;
    return params;
  }, [filters.gender, filters.country, filters.language]);

  useEffect(() => {
    startTransition(async () => {
      const result = await fetchAction({
        "pagination[page]": 1,
        sort: filters.sort,
        ...getFilterParams(),
      });
      setData(result?.data || []);
      setPage(1);
      setHasMore(1 < (result.meta?.pagination?.pageCount ?? 1));
    });
  }, [fetchAction, filters, getFilterParams]);

  const loadMore = useCallback(() => {
    if (!hasMore || isPending) return;

    startTransition(async () => {
      const nextPage = page + 1;
      const result = await fetchAction({
        "pagination[page]": nextPage,
        sort: filters.sort,
        ...getFilterParams(),
      });

      setData((prev) => {
        const existingIds = new Set(prev?.map((f) => f.id));
        const newItems =
          result?.data?.filter((f) => !existingIds.has(f.id)) || [];
        return [...(prev || []), ...newItems];
      });
      setPage(nextPage);
      setHasMore(nextPage < (result.meta?.pagination?.pageCount ?? 1));
    });
  }, [hasMore, isPending, page, filters.sort, getFilterParams, fetchAction]);

  useEffect(() => {
    if (entry?.isIntersecting) {
      loadMore();
    }
  }, [entry?.isIntersecting, loadMore]);

  const clearFilters = () => {
    setFilters({
      gender: null,
      country: null,
      language: null,
      sort: SortOptions.createdAtDesc,
    });
  };

  return (
    <Stack gap="sm">
      <Group justify="space-between" wrap="nowrap">
        <Stack gap={2}>
          <Title order={1} size="h3">
            Following ({initialPagination?.pagination?.total || 0})
          </Title>
          <Text c="dimmed" size="sm">
            Your followed creators live recordings
          </Text>
        </Stack>

        <Indicator
          disabled={activeFilterCount === 0}
          label={activeFilterCount}
          size={16}
        >
          <Button
            variant="light"
            size="lg"
            leftSection={<IconFilter size={16} />}
            onClick={open}
          >
            Filters
          </Button>
        </Indicator>
      </Group>

      {/* Active filters */}

      <Divider />

      <SimpleGrid cols={{ base: 1, sm: 2, md: 3, xl: 4 }} spacing="lg">
        {(data || []).map((rec) => (
          <Grid gutter="xs" key={rec.documentId} w="100%">
            {rec.follower && (
              <Grid.Col span={12}>
                <ImageVideoPreview
                  username={rec.follower?.username || "unknown"}
                  type={rec.follower?.type || FollowerTypeEnum.Tiktok}
                  recording={rec}
                />
              </Grid.Col>
            )}
            <Grid.Col span={12}>
              <Group gap="xs">
                <Anchor
                  component={Link}
                  href={`/${rec.follower?.type}/${rec.follower?.username}`}
                >
                  <Avatar
                    size={38}
                    src={rec.follower?.avatar?.url}
                    styles={{
                      image: { transform: "scale(2)", objectFit: "cover" },
                    }}
                  />
                </Anchor>
                <Stack gap="0">
                  <Anchor
                    component={Link}
                    href={`/${rec.follower?.type}/${rec.follower?.username}`}
                    size="md"
                    truncate
                    maw={110}
                    display="inline-block"
                  >
                    {rec.follower?.username}
                  </Anchor>
                  <Text size="xs">live {dayjs(rec.createdAt).fromNow()}</Text>
                </Stack>
              </Group>
            </Grid.Col>
          </Grid>
        ))}
      </SimpleGrid>

      <div ref={ref} style={{ height: 20 }} />

      {isPending && <Loader size="sm" style={{ alignSelf: "center" }} />}

      {!hasMore && data && data.length > 0 && (
        <Text ta="center" c="dimmed" size="sm">
          No more to load
        </Text>
      )}

      {/* Filter Drawer */}
      <Drawer opened={opened} onClose={close} title="Filters" position="right">
        <Stack gap="md">
          <Select
            label="Sort"
            value={filters.sort}
            onChange={(value) =>
              value && setFilters({ sort: value as SortOptions })
            }
            data={SORT_OPTIONS}
          />
          <Divider />

          <Group grow>
            <Button variant="subtle" onClick={clearFilters}>
              Clear all
            </Button>
            <Button onClick={close}>Done</Button>
          </Group>
        </Stack>
      </Drawer>
    </Stack>
  );
}
