"use client";

import { ActionIcon, Box, Flex, Group, Loader, Modal } from "@mantine/core";
import { useInfiniteQuery } from "@tanstack/react-query";
import { useParams, useRouter, useSearchParams } from "next/navigation";
import { useQueryStates } from "nuqs";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import { VideoPlayer } from "@/app/(protected)/components/video/video-player";
import { fetchRecordings } from "@/app/(protected)/following/actions/fetch-recordings";
import { followingParsers } from "@/app/(protected)/following/lib/search-params";
import { Recording } from "@/lib/types/strapi-autogenerated";
import { IconChevronDown, IconChevronUp, IconX } from "@tabler/icons-react";

export default function RecordingModal() {
  const router = useRouter();
  const params = useParams<{
    id: string;
    username: string;
    type: string;
  }>();
  const searchParams = useSearchParams();

  const [filters] = useQueryStates(followingParsers);
  const containerRef = useRef<HTMLDivElement>(null);
  const slideRefs = useRef<Map<number, HTMLDivElement>>(new Map());
  const [visibleIndex, setVisibleIndex] = useState<number | null>(null);
  const hasScrolledToInitial = useRef(false);

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading } =
    useInfiniteQuery({
      queryKey: ["following", filters],
      queryFn: ({ pageParam }) => fetchRecordings(filters, pageParam),
      initialPageParam: 1,
      getNextPageParam: (lastPage) => {
        const { page = 1, pageCount = 0 } = lastPage.meta?.pagination ?? {};
        return page < pageCount ? page + 1 : undefined;
      },
    });

  const recordings = useMemo(
    () => data?.pages.flatMap((p) => p.data) ?? [],
    [data]
  );

  // Find initial index from URL param
  const initialIndex = useMemo(
    () =>
      Math.max(
        0,
        recordings.findIndex((r) => r.documentId === params.id)
      ),
    [recordings, params.id]
  );

  // Scroll to initial recording once when data loads
  useEffect(() => {
    if (hasScrolledToInitial.current) return;
    if (recordings.length === 0) return;

    if (initialIndex > 0) {
      requestAnimationFrame(() => {
        const target = slideRefs.current.get(initialIndex);
        target?.scrollIntoView({ behavior: "instant" });
      });
    }

    hasScrolledToInitial.current = true;
  }, [initialIndex, recordings.length]);

  // Navigation functions
  const goToPrev = useCallback(() => {
    if (visibleIndex !== null && visibleIndex > 0) {
      const target = slideRefs.current.get(visibleIndex - 1);
      target?.scrollIntoView({ behavior: "smooth" });
    }
  }, [visibleIndex]);

  const goToNext = useCallback(() => {
    if (visibleIndex !== null && visibleIndex < recordings.length - 1) {
      const target = slideRefs.current.get(visibleIndex + 1);
      target?.scrollIntoView({ behavior: "smooth" });
    }
  }, [visibleIndex, recordings.length]);

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
        e.preventDefault();
        goToPrev();
      } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        e.preventDefault();
        goToNext();
      } else if (e.key === "Escape") {
        router.back();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [router, goToPrev, goToNext]);

  const handleClose = () => {
    router.back();
  };

  // Callback for when visible slide changes (called from IntersectionObserver - async, so setState is fine)
  const handleVisibleChange = useCallback(
    (index: number) => {
      setVisibleIndex(index);

      // Update URL
      const recording = recordings[index];
      if (!recording) return;

      const basePath = `/${recording.follower?.type}/${recording.follower?.username}/live/${recording.documentId}`;
      const search = searchParams.toString();
      const url = search ? `${basePath}?${search}` : basePath;
      window.history.replaceState(null, "", url);

      // Prefetch next page when near end
      const isNearEnd = index >= recordings.length - 3;
      if (isNearEnd && hasNextPage && !isFetchingNextPage) {
        fetchNextPage();
      }
    },
    [recordings, searchParams, hasNextPage, isFetchingNextPage, fetchNextPage]
  );

  if (isLoading) {
    return (
      <Modal.Root opened={true} onClose={handleClose} fullScreen>
        <Modal.Content>
          <Flex h="100dvh" justify="center" align="center">
            <Loader size="lg" />
          </Flex>
        </Modal.Content>
      </Modal.Root>
    );
  }

  const showPrev = visibleIndex !== null && visibleIndex > 0;
  const showNext =
    visibleIndex !== null &&
    (visibleIndex < recordings.length - 1 || hasNextPage);

  return (
    <Modal.Root
      opened={true}
      onClose={handleClose}
      fullScreen
      styles={{
        body: { height: "100%", padding: 0, overflow: "hidden" },
        content: { overflow: "hidden" },
      }}
    >
      <Modal.Content>
        <Modal.Body p={0} h="100%">
          {/* Close button - top left */}
          <ActionIcon
            variant="filled"
            radius="xl"
            size="xl"
            color="gray"
            onClick={(e) => {
              e.stopPropagation();
              handleClose();
            }}
            pos="absolute"
            top={20}
            left={20}
            style={{ zIndex: 10 }}
          >
            <IconX />
          </ActionIcon>

          {/* Navigation buttons - right side */}
          <Group
            pos="absolute"
            right={20}
            top="50%"
            gap="xs"
            style={{
              transform: "translateY(-50%)",
              flexDirection: "column",
              zIndex: 10,
            }}
          >
            {showPrev && (
              <ActionIcon
                variant="filled"
                radius="xl"
                size="xl"
                color="gray"
                onClick={goToPrev}
              >
                <IconChevronUp />
              </ActionIcon>
            )}
            {showNext && (
              <ActionIcon
                variant="filled"
                radius="xl"
                size="xl"
                color="gray"
                onClick={goToNext}
                loading={isFetchingNextPage}
              >
                <IconChevronDown />
              </ActionIcon>
            )}
          </Group>

          {/* Scroll container with snap */}
          <Box
            ref={containerRef}
            h="100dvh"
            className="no-scrollbar"
            style={{
              overflowY: "auto",
              scrollSnapType: "y mandatory",
              scrollBehavior: "smooth",
              scrollbarWidth: "none",
              msOverflowStyle: "none",
              overscrollBehavior: "contain",
            }}
          >
            {recordings.map((recording, index) => (
              <VideoSlide
                key={recording.documentId}
                recording={recording}
                index={index}
                isInitiallyVisible={index === initialIndex}
                onVisible={handleVisibleChange}
                registerRef={(el) => {
                  if (el) slideRefs.current.set(index, el);
                  else slideRefs.current.delete(index);
                }}
              />
            ))}
          </Box>
        </Modal.Body>
      </Modal.Content>
    </Modal.Root>
  );
}

function VideoSlide({
  recording,
  index,
  isInitiallyVisible,
  onVisible,
  registerRef,
}: {
  recording: Recording;
  index: number;
  isInitiallyVisible: boolean;
  onVisible: (index: number) => void;
  registerRef: (el: HTMLDivElement | null) => void;
}) {
  const ref = useRef<HTMLDivElement>(null);
  const [isVisible, setIsVisible] = useState(isInitiallyVisible);

  useEffect(() => {
    registerRef(ref.current);
    return () => registerRef(null);
  }, [registerRef]);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsVisible(entry.isIntersecting);
        if (entry.isIntersecting) {
          onVisible(index);
        }
      },
      { threshold: 0.5 }
    );

    observer.observe(element);
    return () => observer.disconnect();
  }, [index, onVisible]);

  return (
    <Flex
      ref={ref}
      h="100dvh"
      justify="center"
      align="center"
      style={{
        scrollSnapAlign: "start",
        scrollSnapStop: "always",
      }}
    >
      {isVisible ? (
        <VideoPlayer recording={recording} key={recording.documentId} />
      ) : (
        <Box w="100%" h="100%" bg="dark.9" />
      )}
    </Flex>
  );
}
