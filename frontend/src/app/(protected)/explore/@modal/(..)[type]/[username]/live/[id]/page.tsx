"use client";

import { ActionIcon, Box, Flex, Group, Modal } from "@mantine/core";
import { useInfiniteQuery } from "@tanstack/react-query";
import { useParams, useRouter, useSearchParams } from "next/navigation";
import { useQueryStates } from "nuqs";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import { VideoPlayer } from "@/app/(protected)/components/video/video-player";
import { fetchRecordings } from "@/app/(protected)/following/actions/fetch-recordings";
import { followingParsers } from "@/app/(protected)/following/lib/search-params";
import { Recording } from "@/lib/types/strapi-autogenerated";
import { IconChevronDown, IconChevronUp, IconX } from "@tabler/icons-react";

export default function RecordingModal() {
  const router = useRouter();
  const params = useParams<{
    id: string;
    username: string;
    type: string;
  }>();
  const searchParams = useSearchParams();

  const [filters] = useQueryStates(followingParsers);
  const containerRef = useRef<HTMLDivElement>(null);
  const slideRefs = useRef<Map<number, HTMLDivElement>>(new Map());
  const [visibleIndex, setVisibleIndex] = useState<number>(0);

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
    useInfiniteQuery({
      queryKey: ["explore", filters],
      queryFn: ({ pageParam }) => fetchRecordings(filters, pageParam),
      initialPageParam: 1,
      getNextPageParam: (lastPage) => {
        const { page = 1, pageCount = 0 } = lastPage.meta?.pagination ?? {};
        return page < pageCount ? page + 1 : undefined;
      },
    });

  const recordings = useMemo(
    () => data?.pages.flatMap((p) => p.data) ?? [],
    [data]
  );

  // Find initial index from URL param
  const initialIndex = useMemo(
    () => recordings.findIndex((r) => r.documentId === params.id),
    [recordings, params.id]
  );

  // Scroll to initial recording on mount
  useEffect(() => {
    if (initialIndex > 0) {
      const target = slideRefs.current.get(initialIndex);
      target?.scrollIntoView({ behavior: "instant" });
    }
  }, [initialIndex]);

  // Navigation functions
  const goToPrev = useCallback(() => {
    if (visibleIndex > 0) {
      const target = slideRefs.current.get(visibleIndex - 1);
      target?.scrollIntoView({ behavior: "smooth" });
    }
  }, [visibleIndex]);

  const goToNext = useCallback(() => {
    if (visibleIndex < recordings.length - 1) {
      const target = slideRefs.current.get(visibleIndex + 1);
      target?.scrollIntoView({ behavior: "smooth" });
    }
  }, [visibleIndex, recordings.length]);

  // Update URL when visible recording changes
  useEffect(() => {
    const recording = recordings[visibleIndex];
    if (!recording) return;

    const basePath = `/${recording.follower?.type}/${recording.follower?.username}/live/${recording.documentId}`;
    const search = searchParams.toString();
    const url = search ? `${basePath}?${search}` : basePath;

    window.history.replaceState(null, "", url);
  }, [visibleIndex, recordings, searchParams]);

  // Prefetch next page when near end
  useEffect(() => {
    const isNearEnd = visibleIndex >= recordings.length - 3;
    if (isNearEnd && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [
    visibleIndex,
    recordings.length,
    hasNextPage,
    isFetchingNextPage,
    fetchNextPage,
  ]);

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
        e.preventDefault();
        goToPrev();
      } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        e.preventDefault();
        goToNext();
      } else if (e.key === "Escape") {
        router.back();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [router, goToPrev, goToNext]);

  const handleClose = () => {
    router.back();
  };

  const showPrev = visibleIndex > 0;
  const showNext = visibleIndex < recordings.length - 1 || hasNextPage;

  return (
    <Modal.Root
      opened={true}
      onClose={handleClose}
      fullScreen
      styles={{
        body: { height: "100%", padding: 0, overflow: "hidden" },
        content: { overflow: "hidden" },
      }}
    >
      <Modal.Content>
        <Modal.Body p={0} h="100%">
          {/* Close button - top left */}
          <ActionIcon
            variant="filled"
            radius="xl"
            size="xl"
            color="gray"
            onClick={handleClose}
            pos="absolute"
            top={20}
            left={20}
            style={{ zIndex: 10 }}
          >
            <IconX />
          </ActionIcon>

          {/* Navigation buttons - right side */}
          <Group
            pos="absolute"
            right={20}
            top="50%"
            gap="xs"
            style={{
              transform: "translateY(-50%)",
              flexDirection: "column",
              zIndex: 10,
            }}
          >
            {showPrev && (
              <ActionIcon
                variant="filled"
                radius="xl"
                size="xl"
                color="gray"
                onClick={goToPrev}
              >
                <IconChevronUp />
              </ActionIcon>
            )}
            {showNext && (
              <ActionIcon
                variant="filled"
                radius="xl"
                size="xl"
                color="gray"
                onClick={goToNext}
                loading={isFetchingNextPage}
              >
                <IconChevronDown />
              </ActionIcon>
            )}
          </Group>

          {/* Scroll container with snap */}
          <Box
            ref={containerRef}
            h="100vh"
            className="no-scrollbar"
            style={{
              overflowY: "auto",
              scrollSnapType: "y mandatory",
              scrollBehavior: "smooth",
              scrollbarWidth: "none",
              msOverflowStyle: "none",
            }}
          >
            {recordings.map((recording, index) => (
              <VideoSlide
                key={recording.documentId}
                recording={recording}
                index={index}
                visibleIndex={visibleIndex}
                onVisible={setVisibleIndex}
                registerRef={(el) => {
                  if (el) slideRefs.current.set(index, el);
                  else slideRefs.current.delete(index);
                }}
              />
            ))}
          </Box>
        </Modal.Body>
      </Modal.Content>
    </Modal.Root>
  );
}

function VideoSlide({
  recording,
  index,
  visibleIndex,
  onVisible,
  registerRef,
}: {
  recording: Recording;
  index: number;
  visibleIndex: number;
  onVisible: (index: number) => void;
  registerRef: (el: HTMLDivElement | null) => void;
}) {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    registerRef(ref.current);
    return () => registerRef(null);
  }, [registerRef]);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          onVisible(index);
        }
      },
      { threshold: 0.5 }
    );

    observer.observe(element);
    return () => observer.disconnect();
  }, [index, onVisible]);

  const sources = recording.sources ?? [];
  const isVisible = visibleIndex === index;

  return (
    <Flex
      ref={ref}
      h="100vh"
      justify="center"
      align="center"
      style={{ scrollSnapAlign: "start" }}
    >
      {isVisible ? (
        <VideoPlayer sources={sources} key={recording.documentId} />
      ) : (
        // Placeholder - could show thumbnail if available
        <Box w="100%" h="100%" bg="dark.9" />
      )}
    </Flex>
  );
}
