// components/infinite-followers.tsx
"use client";

import { getFollowers } from "@/app/actions/followers";

import dayjs from "@/app/lib/dayjs";
import { SortOptions } from "@/lib/types/filtering";
import {
  BrowseFollowersResponse,
  ScopeEnum,
  SourceStateEnum,
  type FollowerWithMeta,
} from "@/lib/types/strapi-autogenerated";
import {
  ActionIcon,
  Anchor,
  Avatar,
  Box,
  Card,
  Checkbox,
  Divider,
  Flex,
  Grid,
  Group,
  Image,
  Loader,
  Select,
  Stack,
  Text,
  Title,
  Tooltip,
  useMatches,
} from "@mantine/core";
import { useIntersection } from "@mantine/hooks";
import { IconGrid4x4, IconList, IconWindowMaximize } from "@tabler/icons-react";
import Link from "next/link";
import { parseAsBoolean, parseAsStringEnum, useQueryState } from "nuqs";
import { useEffect, useState, useTransition } from "react";
import { ImageVideoPreview } from "../recordings/_components/image-video-preview";
import { CountryFlag } from "./country-flag";
import FollowButton from "./follow-button";
import UnfollowButton from "./unfollow-button";

const SORT_OPTIONS = [
  { value: SortOptions.UsernameAsc, label: "Username A-Z" },
  { value: SortOptions.UsernameDesc, label: "Username Z-A" },
  { value: SortOptions.createdAtDesc, label: "Newest followers" },
  { value: SortOptions.createdAtAsc, label: "Oldest followers" },
];

enum ViewOptions {
  grid = "grid",
  list = "list",
}

interface Props {
  title: string;
  initialData: FollowerWithMeta[];
  initialPagination: BrowseFollowersResponse["meta"];
  initialSort?: SortOptions;
  initialScope: ScopeEnum;
  fetchAction: (
    options: Parameters<typeof getFollowers>[0]
  ) => ReturnType<typeof getFollowers>;
}

export default function InfiniteFollowers({
  title,
  initialData,
  initialPagination,
  initialSort,
  initialScope,
  fetchAction,
}: Props) {
  const cardPadding = useMatches({
    base: "sm",
    sm: "md",
    md: "lg",
  });

  const mawTruncate = useMatches({
    base: 200,
    md: 120,
  });

  const [data, setData] = useState(initialData);
  const [page, setPage] = useState(initialPagination?.pagination?.page ?? 1);
  const [hasMore, setHasMore] = useState(
    page < (initialPagination?.pagination?.pageCount ?? 1)
  );
  const [sort, setSort] = useQueryState(
    "sort",
    parseAsStringEnum<SortOptions>(Object.values(SortOptions)).withDefault(
      initialSort || SortOptions.createdAtDesc
    )
  );
  const [hasRecordings, setHasRecordings] = useQueryState(
    "hasRecordings",
    parseAsBoolean.withDefault(true)
  );

  const [view, setView] = useQueryState(
    "view",
    parseAsStringEnum<ViewOptions>(Object.values(ViewOptions)).withDefault(
      ViewOptions.list
    )
  );
  const [isPending, startTransition] = useTransition();

  const { ref, entry } = useIntersection({
    threshold: 0.5,
  });

  const update = (object = {}) => {
    startTransition(async () => {
      const result = await fetchAction({
        page: 1,
        sort,
        hasRecordings,
        scope: initialScope,
        ...object,
      });
      setData(result.data);
      setPage(1);
      setHasMore(1 < (result.meta?.pagination?.pageCount ?? 1));
    });
  };

  const handleSortChange = (sort: string | null) => {
    if (!sort) return;
    setSort(sort as unknown as SortOptions);
    update({ sort });
  };

  const handleHasRecordingsChange = (hasRecordings: boolean | null) => {
    setHasRecordings(hasRecordings);
    update({ hasRecordings });
  };

  const handleFollowed = (id: number) => {
    setData((prev) => prev.filter((f) => f.id !== id));
  };

  useEffect(() => {
    if (entry?.isIntersecting && hasMore && !isPending) {
      startTransition(async () => {
        const nextPage = page + 1;
        const result = await fetchAction({
          page: nextPage,
          sort,
          hasRecordings,
          scope: initialScope,
        });

        setData((prev) => {
          const existingIds = new Set(prev.map((f) => f.id));
          const newItems = result.data.filter((f) => !existingIds.has(f.id));
          return [...prev, ...newItems];
        });
        setPage(nextPage);
        setHasMore(nextPage < (result.meta?.pagination?.pageCount ?? 1));
      });
    }
  }, [
    entry?.isIntersecting,
    hasMore,
    hasRecordings,
    isPending,
    page,
    sort,
    fetchAction,
    initialScope,
  ]);

  return (
    <Stack gap="sm">
      <Group justify="space-between">
        <Title order={1} size="lg">
          {title}{" "}
          {initialScope === ScopeEnum.Following
            ? initialPagination?.pagination?.total || 0
            : ""}
        </Title>

        <Group>
          {initialScope === ScopeEnum.Discover ? (
            <Checkbox
              label="Show only streamers with recordings"
              checked={hasRecordings}
              onChange={(event) =>
                handleHasRecordingsChange(event.currentTarget.checked)
              }
            />
          ) : null}
          <Tooltip label="Grid view">
            <ActionIcon
              variant={view === ViewOptions.grid ? undefined : "default"}
              onClick={() => setView(ViewOptions.grid)}
            >
              <IconGrid4x4 />
            </ActionIcon>
          </Tooltip>
          <Tooltip label="List view">
            <ActionIcon
              variant={view === ViewOptions.list ? undefined : "default"}
              onClick={() => setView(ViewOptions.list)}
            >
              <IconList />
            </ActionIcon>
          </Tooltip>
          <Select
            key={sort}
            size="sm"
            w={180}
            value={sort}
            onChange={handleSortChange}
            data={SORT_OPTIONS}
            disabled={isPending}
          />
        </Group>
      </Group>
      <Divider />
      <Stack gap="md">
        <Grid justify="flex-start" align="stretch">
          {data.map((follower) => (
            <Grid.Col
              key={follower.documentId}
              span={view === "list" ? 12 : { base: 12, md: 6, lg: 4 }}
            >
              <Card
                shadow="sm"
                padding={cardPadding}
                radius="md"
                bg="gray.7"
                h="100%"
                withBorder
              >
                <Flex justify="space-between">
                  <Group>
                    <Anchor
                      component={Link}
                      href={`/${follower?.type}/${follower?.username}`}
                    >
                      <Avatar
                        size="lg"
                        src={follower.avatar?.url}
                        styles={{
                          image: {
                            transform: "scale(2)",
                            objectFit: "cover",
                          },
                        }}
                      />
                    </Anchor>

                    <Stack gap="0">
                      <Group gap="xs">
                        <Anchor
                          component={Link}
                          href={`/${follower?.type}/${follower?.username}`}
                          size="md"
                        >
                          <Text size="lg" truncate maw={mawTruncate} fw="bold">
                            {follower.username}
                          </Text>
                        </Anchor>
                        {follower.country ? (
                          <CountryFlag country={follower?.country} />
                        ) : null}
                      </Group>
                      <Text size="md" c="gray.4">
                        {follower.totalRecordings} recordings
                      </Text>
                    </Stack>
                  </Group>
                  {view === "list" ? (
                    <Flex gap="xs" justify="right" align="center">
                      <Tooltip label="Go to tiktok">
                        <ActionIcon
                          size="lg"
                          component={Link}
                          href={`https://www.tiktok.com/@${follower.username}/live`}
                          target="_blank"
                        >
                          <IconWindowMaximize size={24} />
                        </ActionIcon>
                      </Tooltip>

                      {follower.isFollowing ? (
                        <>
                          <UnfollowButton
                            documentId={follower.documentId!}
                            onSuccess={() => handleFollowed(follower.id!)}
                          />
                        </>
                      ) : (
                        <FollowButton
                          username={follower.username!}
                          type={follower.type}
                          onSuccess={() => handleFollowed(follower.id!)}
                        />
                      )}
                    </Flex>
                  ) : null}
                </Flex>
                {follower.recordings && follower.recordings?.length > 0 ? (
                  <Box mt="lg">
                    <div
                      style={{
                        display: "grid",
                        gridTemplateColumns: "repeat(auto-fill, 160px)",
                        gridAutoRows: "306px",
                        gap: "1.4em",
                        maxHeight: 306,
                        overflow: "hidden",
                      }}
                    >
                      {follower.recordings?.map((rec) => {
                        const isRecording = rec.sources?.some(
                          (s) => s.state === SourceStateEnum.Recording
                        );

                        return (
                          <Stack key={rec.documentId} gap="4">
                            <ImageVideoPreview
                              href={`/${follower.type}/${follower.username}/live/${rec.documentId}`}
                              w={160}
                              h={284}
                              sources={rec.sources}
                            />
                            <div>
                              <Text size="xs">
                                {isRecording
                                  ? `recording for ${dayjs(
                                      rec.createdAt
                                    ).fromNow(true)}`
                                  : `recorded ${dayjs(
                                      rec.createdAt
                                    ).fromNow()}`}
                              </Text>
                            </div>
                          </Stack>
                        );
                      })}
                    </div>
                  </Box>
                ) : (
                  <Box
                    mt="lg"
                    pos="relative"
                    w={160}
                    h={284}
                    style={{
                      overflow: "hidden",
                      borderRadius: "var(--mantine-radius-md)",
                    }}
                  >
                    <Image
                      alt="no videos"
                      radius="md"
                      src="https://placehold.co/180x280/1a1b1e/909296?text=No videos yet"
                      w={160}
                      h={284}
                      loading="lazy"
                      style={{ objectFit: "cover", opacity: 0.8 }}
                    />
                  </Box>
                )}
              </Card>
            </Grid.Col>
          ))}
        </Grid>
      </Stack>
      {/* Sentinel element */}
      <div ref={ref} style={{ height: 1 }} />

      {isPending && <Loader size="sm" style={{ alignSelf: "center" }} />}

      {!hasMore && data.length > 0 && (
        <p style={{ textAlign: "center", color: "gray" }}>No more to load</p>
      )}
    </Stack>
  );
}
