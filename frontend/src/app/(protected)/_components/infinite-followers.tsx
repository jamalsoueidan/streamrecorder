// components/infinite-followers.tsx
"use client";

import { getFollowers } from "@/app/actions/followers";

import dayjs from "@/app/lib/dayjs";
import { SortOptions } from "@/lib/types/filtering";
import {
  BrowseFollowersResponse,
  ScopeEnum,
  type FollowerWithMeta,
} from "@/lib/types/strapi-autogenerated";
import {
  Avatar,
  Box,
  Card,
  Divider,
  Grid,
  Group,
  Loader,
  Select,
  Stack,
  Text,
  Title,
} from "@mantine/core";
import { useIntersection } from "@mantine/hooks";
import { parseAsStringEnum, useQueryState } from "nuqs";
import { useEffect, useState, useTransition } from "react";
import { ImageVideoPreview } from "../recordings/_components/image-video-preview";
import FollowButton from "./follow-button";
import UnfollowButton from "./unfollow-button";

const SORT_OPTIONS = [
  { value: SortOptions.UsernameAsc, label: "Username A-Z" },
  { value: SortOptions.UsernameDesc, label: "Username Z-A" },
  { value: SortOptions.createdAtDesc, label: "Newest first" },
  { value: SortOptions.createdAtAsc, label: "Oldest first" },
];

interface Props {
  title: string;
  initialData: FollowerWithMeta[];
  initialPagination: BrowseFollowersResponse["meta"];
  initialSort?: SortOptions;
  initialScope: ScopeEnum;
}

export default function InfiniteFollowers({
  title,
  initialData,
  initialPagination,
  initialSort,
  initialScope,
}: Props) {
  const [data, setData] = useState(initialData);
  const [page, setPage] = useState(initialPagination?.pagination?.page ?? 1);
  const [hasMore, setHasMore] = useState(
    page < (initialPagination?.pagination?.pageCount ?? 1)
  );
  const [sort, setSort] = useQueryState(
    "sort",
    parseAsStringEnum<SortOptions>(Object.values(SortOptions)).withDefault(
      initialSort || SortOptions.createdAtDesc
    )
  );
  const [isPending, startTransition] = useTransition();

  const { ref, entry } = useIntersection({
    threshold: 0.5,
  });

  const handleSortChange = (value: string | null) => {
    if (!value) return;

    setSort(value as unknown as SortOptions);
    startTransition(async () => {
      const result = await getFollowers({
        scope: initialScope,
        page: 1,
        sort: value as unknown as SortOptions,
      });
      setData(result.data);
      setPage(1);
      setHasMore(1 < (result.meta?.pagination?.pageCount ?? 1));
    });
  };

  const handleFollowed = (id: number) => {
    setData((prev) => prev.filter((f) => f.id !== id));
  };

  useEffect(() => {
    if (entry?.isIntersecting && hasMore && !isPending) {
      startTransition(async () => {
        const nextPage = page + 1;
        const result = await getFollowers({
          scope: ScopeEnum.Discover,
          page: nextPage,
          sort,
        });

        setData((prev) => {
          const existingIds = new Set(prev.map((f) => f.id));
          const newItems = result.data.filter((f) => !existingIds.has(f.id));
          return [...prev, ...newItems];
        });
        setPage(nextPage);
        setHasMore(nextPage < (result.meta?.pagination?.pageCount ?? 1));
      });
    }
  }, [entry?.isIntersecting, hasMore, isPending, page, sort]);

  return (
    <Stack gap="sm">
      <Group justify="space-between">
        <Title order={1} size="lg">
          {title} ({initialPagination?.pagination?.total || 0})
        </Title>

        <Select
          key={sort}
          size="sm"
          w={180}
          value={sort}
          onChange={handleSortChange}
          data={SORT_OPTIONS}
          disabled={isPending}
        />
      </Group>
      <Divider />
      <Stack gap="md">
        {data.map((f) => (
          <Card
            key={f.documentId}
            shadow="sm"
            padding="lg"
            radius="md"
            bg="gray.9"
            withBorder
          >
            <Grid justify="center" align="center">
              <Grid.Col span="content">
                <Avatar
                  size="lg"
                  src={
                    f.recordings?.at(0)?.sources?.at(0)?.path
                      ? process.env.NEXT_PUBLIC_S3_URL! +
                        f.recordings?.at(0)?.sources?.at(0)?.path +
                        "preview.jpg"
                      : null
                  }
                  styles={{
                    image: {
                      transform: "scale(2)",
                      objectFit: "cover",
                    },
                  }}
                />
              </Grid.Col>
              <Grid.Col span="auto">
                <Title order={2} size="md">
                  {f.username}
                </Title>
                <Text>{f.totalRecordings} recordings</Text>

                <Text size="xs">added {dayjs(f.createdAt).fromNow()}</Text>
              </Grid.Col>
              <Grid.Col span={2} style={{ textAlign: "right" }}>
                {f.isFollowing ? (
                  <UnfollowButton
                    id={f.id!}
                    onSuccess={() => handleFollowed(f.id!)}
                  />
                ) : (
                  <FollowButton
                    username={f.username!}
                    type={f.type}
                    onSuccess={() => handleFollowed(f.id!)}
                  />
                )}
              </Grid.Col>
            </Grid>
            <Box mt="sm">
              <div
                style={{
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fill, 160px)",
                  gridAutoRows: "306px",
                  gap: "1.4em",
                  maxHeight: 306,
                  overflow: "hidden",
                }}
              >
                {f.recordings?.slice(0, 7).map((rec) => {
                  const path = rec.sources?.length
                    ? process.env.NEXT_PUBLIC_S3_URL! +
                      rec.sources[0].path +
                      "preview.jpg"
                    : null;

                  return (
                    <Stack key={rec.documentId} gap="4">
                      <ImageVideoPreview
                        href={`/${f.type}/${f.username}/live/${rec.documentId}`}
                        src={path}
                        w={160}
                        h={284}
                        sources={rec.sources}
                      />
                      <div>
                        <Text size="xs">
                          recorded {dayjs(f.createdAt).fromNow()}
                        </Text>
                      </div>
                    </Stack>
                  );
                })}
              </div>
            </Box>
          </Card>
        ))}
      </Stack>
      {/* Sentinel element */}
      <div ref={ref} style={{ height: 1 }} />

      {isPending && <Loader size="sm" style={{ alignSelf: "center" }} />}

      {!hasMore && data.length > 0 && (
        <p style={{ textAlign: "center", color: "gray" }}>No more to load</p>
      )}
    </Stack>
  );
}
