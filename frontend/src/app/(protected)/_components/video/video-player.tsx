"use client";

import { Source } from "@/lib/types/strapi-autogenerated";
import "hls-video-element";
import "media-chrome";
import { useSearchParams } from "next/navigation";
import { useEffect, useMemo, useRef, useState } from "react";
import {
  HlsVideo,
  MediaControlBar,
  MediaController,
  MediaSeekForwardButton,
  MediaTimeDisplay,
  MediaTimeRange,
} from "./media-chrome";
import { buildVideoRanges, combinePlaylistsFromSources } from "./player-utils";

export function VideoPlayer({ sources }: { sources: Source[] }) {
  const searchParams = useSearchParams();
  const startTime = Number(searchParams.get("t")) || 0;

  const [rotation, setRotation] = useState(0);
  const [ready, setReady] = useState(false);
  const controllerRef = useRef<HTMLElement>(null);
  const videoRef = useRef<HTMLVideoElement>(null);

  const videoRanges = useMemo(() => buildVideoRanges(sources), [sources]);

  const vttDataUrl = useMemo(() => {
    if (!videoRanges.length) return null;

    const thumbWidth = 160;
    const thumbHeight = 284;
    let vtt = "WEBVTT\n\n";

    for (const range of videoRanges) {
      if (!range.path) continue;

      const spriteUrl = `${process.env.NEXT_PUBLIC_S3_URL}${range.path}thumbnails.jpg`;
      const numThumbs = Math.ceil((range.end - range.start) / range.interval);

      for (let i = 0; i < numThumbs; i++) {
        const cueStart = range.start + i * range.interval;
        const cueEnd = Math.min(
          range.start + (i + 1) * range.interval,
          range.end
        );

        const col = i % range.cols;
        const row = Math.floor(i / range.cols);
        const x = col * thumbWidth;
        const y = row * thumbHeight;

        vtt += `${formatTime(cueStart)} --> ${formatTime(cueEnd)}\n`;
        vtt += `${spriteUrl}#xywh=${x},${y},${thumbWidth},${thumbHeight}\n\n`;
      }
    }

    return `data:text/vtt;charset=utf-8,${encodeURIComponent(vtt)}`;
  }, [videoRanges]);

  const playlistDataUrl = useMemo(() => {
    if (!sources?.length) return null;
    const playlist = combinePlaylistsFromSources(sources, "original");
    if (!playlist) return null;
    return `data:application/vnd.apple.mpegurl;charset=utf-8,${encodeURIComponent(
      playlist
    )}`;
  }, [sources]);

  // Handle seek and autoplay
  useEffect(() => {
    const video = videoRef.current as any;
    if (!video) return;

    const handleLoaded = () => {
      if (startTime > 0) {
        video.currentTime = startTime;
      } else {
        setReady(true);
        video.play().catch(() => {});
      }
    };

    const handleSeeked = () => {
      setReady(true);
      video.play().catch(() => {});
    };

    video.addEventListener("loadedmetadata", handleLoaded, { once: true });
    video.addEventListener("seeked", handleSeeked, { once: true });

    return () => {
      video.removeEventListener("loadedmetadata", handleLoaded);
      video.removeEventListener("seeked", handleSeeked);
    };
  }, [startTime]);

  const handleDoubleClick = () => {
    const controller = controllerRef.current;
    if (!controller) return;

    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      controller.requestFullscreen();
    }
  };

  if (!playlistDataUrl) return null;

  return (
    <div style={{ position: "relative", width: "100%", height: "100%" }}>
      {/* Loading overlay */}
      {!ready && (
        <div
          style={{
            position: "absolute",
            inset: 0,
            background: "#000",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            pointerEvents: "none",
            zIndex: 10,
          }}
        >
          <div
            style={{
              width: 40,
              height: 40,
              border: "3px solid rgba(255,255,255,0.3)",
              borderTopColor: "#fff",
              borderRadius: "50%",
              animation: "spin 0.8s linear infinite",
            }}
          />
        </div>
      )}

      <MediaController
        ref={controllerRef}
        onDoubleClick={handleDoubleClick}
        style={{
          width: "100%",
          height: "100%",
          background: "#000",
          opacity: ready ? 1 : 0,
        }}
      >
        <HlsVideo
          ref={videoRef}
          src={playlistDataUrl}
          slot="media"
          crossOrigin="anonymous"
          playsInline
          style={{
            transform: `rotate(${rotation}deg)`,
            transition: "transform 0.3s ease",
          }}
        >
          {vttDataUrl && (
            <track
              default
              kind="metadata"
              label="thumbnails"
              src={vttDataUrl}
            />
          )}
        </HlsVideo>

        <MediaControlBar>
          <MediaTimeDisplay show-duration />
          <MediaTimeRange />
          <MediaSeekForwardButton seekoffset="10" />
        </MediaControlBar>
      </MediaController>

      <style jsx>{`
        @keyframes spin {
          to {
            transform: rotate(360deg);
          }
        }
      `}</style>
    </div>
  );
}

function formatTime(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${hrs.toString().padStart(2, "0")}:${mins
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")}.${ms
    .toString()
    .padStart(3, "0")}`;
}
