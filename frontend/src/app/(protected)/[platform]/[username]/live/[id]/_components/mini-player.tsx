// mini-player.tsx
"use client";

import { combinePlaylistsFromSources } from "@/app/(protected)/[platform]/[username]/live/[id]/_components/player-utils";
import { Source } from "@/lib/types/strapi-autogenerated";
import { useMounted } from "@mantine/hooks";
import { useEffect, useRef, useState } from "react";
import videojs from "video.js";
import Player from "video.js/dist/types/player";
import "video.js/dist/video-js.css";

interface Props {
  sources: Source[];
  width: number;
  height: number;
}

export function MiniPlayer({ sources, width, height }: Props) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const playerRef = useRef<Player | null>(null);
  const playlistUrlRef = useRef<string | null>(null);
  const mounted = useMounted();
  const [progress, setProgress] = useState(0);
  const [loading, setLoading] = useState(true);
  const [seeking, setSeeking] = useState(false);
  const [dragging, setDragging] = useState(false);

  const totalDuration = sources.reduce((sum, s) => sum + (s.duration || 0), 0);

  useEffect(() => {
    if (!mounted || !sources || sources.length === 0) return;

    const smallMissing = sources.some((s) => !s.videoSmall);

    const combinedPlaylist = combinePlaylistsFromSources(
      sources,
      smallMissing ? "original" : "small"
    );

    if (!combinedPlaylist || combinedPlaylist.length < 50) return;

    const blob = new Blob([combinedPlaylist], {
      type: "application/vnd.apple.mpegurl",
    });
    const playlistUrl = URL.createObjectURL(blob);
    playlistUrlRef.current = playlistUrl;

    if (videoRef.current && !playerRef.current) {
      const player = videojs(videoRef.current, {
        autoplay: true,
        muted: true,
        controls: false,
        responsive: false,
        loadingSpinner: false,
        html5: {
          vhs: {
            overrideNative: true,
          },
          nativeAudioTracks: false,
          nativeVideoTracks: false,
        },
      });

      player.src({
        src: playlistUrl,
        type: "application/x-mpegURL",
      });

      player.on("playing", () => {
        setLoading(false);
      });

      player.on("timeupdate", () => {
        if (!dragging) {
          const current = player.currentTime() || 0;
          const duration = player.duration() || totalDuration;
          setProgress((current / duration) * 100);
        }
      });

      player.on("seeking", () => setSeeking(true));
      player.on("seeked", () => setSeeking(false));

      playerRef.current = player;
    }

    return () => {
      if (playerRef.current) {
        playerRef.current.dispose();
        playerRef.current = null;
      }
      if (playlistUrlRef.current) {
        URL.revokeObjectURL(playlistUrlRef.current);
        playlistUrlRef.current = null;
      }
    };
  }, [mounted, sources, totalDuration, dragging]);

  const handleSeek = (clientX: number, rect: DOMRect) => {
    if (!playerRef.current) return;
    const percent = Math.max(
      0,
      Math.min(1, (clientX - rect.left) / rect.width)
    );
    setProgress(percent * 100);
    const duration = playerRef.current.duration() || totalDuration;
    playerRef.current.currentTime(percent * duration);
  };

  const handleProgressClick = (e: React.MouseEvent<HTMLDivElement>) => {
    handleSeek(e.clientX, e.currentTarget.getBoundingClientRect());
  };

  const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setDragging(true);
    const progressBar = e.currentTarget.parentElement!.parentElement!;
    const rect = progressBar.getBoundingClientRect();

    const handleMouseMove = (e: MouseEvent) => {
      handleSeek(e.clientX, rect);
    };

    const handleMouseUp = () => {
      setDragging(false);
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  };

  if (!mounted) return null;

  const showSpinner = loading || seeking;

  return (
    <div
      className="mini-player-wrapper"
      style={{
        width,
        height,
        borderRadius: 8, // or use a prop
        overflow: "hidden", // Important! Clips video to rounded corners
        position: "relative", // Add this too for absolute children
      }}
    >
      <style jsx global>{`
        @keyframes mini-player-spin {
          to {
            transform: rotate(360deg);
          }
        }

        .mini-player-wrapper .video-js,
        .mini-player-wrapper .vjs-tech,
        .mini-player-wrapper [data-vjs-player] {
          width: 100% !important;
          height: 100% !important;
          background: transparent !important;
          background-color: transparent !important;
        }

        .mini-player-wrapper .vjs-tech {
          object-fit: cover;
        }

        .mini-player-wrapper .vjs-control-bar,
        .mini-player-wrapper .vjs-big-play-button,
        .mini-player-wrapper .vjs-loading-spinner,
        .mini-player-wrapper .vjs-poster,
        .mini-player-wrapper .vjs-modal-dialog,
        .vjs-loading-spinner {
          display: none !important;
          visibility: hidden !important;
          opacity: 0 !important;
        }
      `}</style>

      {/* Video - hidden until loaded */}
      <div
        data-vjs-player
        style={{
          width: "100%",
          height: "100%",
          opacity: loading ? 0 : 1,
          transition: "opacity 0.2s ease",
        }}
      >
        <video
          ref={videoRef}
          className="video-js vjs-default-skin"
          playsInline
        />
      </div>

      {/* Loading spinner - shows during initial load and seeking */}
      {showSpinner && (
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            background: "rgba(0,0,0,0.6)",
            borderRadius: "50%",
            width: 40,
            height: 40,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          <div
            style={{
              width: 20,
              height: 20,
              border: "2px solid #fff",
              borderTopColor: "transparent",
              borderRadius: "50%",
              animation: "mini-player-spin 0.8s linear infinite",
            }}
          />
        </div>
      )}

      {/* Progress bar - only show when video is loaded */}
      {!loading && (
        <div
          onClick={handleProgressClick}
          style={{
            position: "absolute",
            bottom: 0,
            left: 0,
            right: 0,
            height: 20,
            paddingTop: 12,
            cursor: "pointer",
            zIndex: 10,
          }}
        >
          {/* Track background */}
          <div
            style={{
              height: 8,
              background: "rgba(255,255,255,0.3)",
              borderRadius: 4,
              position: "relative",
            }}
          >
            {/* Progress fill */}
            <div
              style={{
                height: "100%",
                width: `${progress}%`,
                background: "#fff",
                borderRadius: 4,
                position: "relative",
              }}
            >
              {/* Draggable thumb */}
              <div
                onMouseDown={handleMouseDown}
                style={{
                  position: "absolute",
                  right: -6,
                  top: "50%",
                  transform: "translateY(-50%)",
                  width: 12,
                  height: 12,
                  background: "#fff",
                  borderRadius: "50%",
                  cursor: "grab",
                  boxShadow: "0 1px 4px rgba(0,0,0,0.4)",
                }}
              />
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
