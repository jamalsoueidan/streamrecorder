"use client";

import {
  BrowseFollowersData,
  BrowseFollowersResponse,
  type FollowerWithMeta,
} from "@/lib/types/strapi-autogenerated";
import { Grid, Loader, Stack } from "@mantine/core";
import { useIntersection } from "@mantine/hooks";
import { useCallback, useEffect, useState, useTransition } from "react";

import api from "@/lib/api";
import { useQueryStates } from "nuqs";
import { discoverParsers } from "../lib/search-params";
import FollowerItem from "./follower-item";

interface Props {
  initialData: FollowerWithMeta[];
  initialPagination: BrowseFollowersResponse["meta"];
  fetchAction: (
    options: Parameters<typeof api.follower.browseFollowers>[0]
  ) => Promise<BrowseFollowersData>;
}

export default function CreatorsInfinity({
  initialData,
  initialPagination,
  fetchAction,
}: Props) {
  const [filters] = useQueryStates(discoverParsers);
  const [data, setData] = useState(initialData);
  const [page, setPage] = useState(initialPagination?.pagination?.page ?? 1);
  const [hasMore, setHasMore] = useState(
    page < (initialPagination?.pagination?.pageCount ?? 1)
  );

  const [isPending, startTransition] = useTransition();

  const { ref, entry } = useIntersection({
    threshold: 0.5,
  });

  useEffect(() => {
    startTransition(async () => {
      const result = await fetchAction({
        "pagination[page]": 1,
        filters: {
          ...(filters.gender && { gender: { $eq: filters.gender } }),
          ...(filters.country && { countryCode: { $eq: filters.country } }),
          ...(filters.language && { languageCode: { $eq: filters.language } }),
          ...(filters.type && { type: { $eq: filters.type } }),
        },
        scope: filters.scope,
        hasRecordings: filters.hasRecordings,
      });
      setData(result?.data || []);
      setPage(1);
    });
  }, [filters, fetchAction]);

  const loadMore = useCallback(() => {
    if (!hasMore || isPending) return;

    startTransition(async () => {
      const nextPage = page + 1;
      const result = await fetchAction({
        "pagination[page]": nextPage,
        filters: {
          ...(filters.gender && { gender: { $eq: filters.gender } }),
          ...(filters.country && { countryCode: { $eq: filters.country } }),
          ...(filters.language && { languageCode: { $eq: filters.language } }),
          ...(filters.type && { type: { $eq: filters.type } }),
        },
        scope: filters.scope,
        hasRecordings: filters.hasRecordings,
      });

      setData((prev) => {
        const existingIds = new Set(prev.map((f) => f.id));
        const newItems =
          result?.data?.filter((f) => !existingIds.has(f.id)) || [];
        return [...prev, ...newItems];
      });
      setPage(nextPage);
      setHasMore(nextPage < (result.meta?.pagination?.pageCount ?? 1));
    });
  }, [hasMore, isPending, page, fetchAction, filters]);

  useEffect(() => {
    if (entry?.isIntersecting) {
      loadMore();
    }
  }, [entry?.isIntersecting, loadMore]);

  return (
    <>
      <Stack gap="md">
        <Grid justify="flex-start" align="stretch">
          {data.map((follower) => (
            <FollowerItem key={follower.documentId} follower={follower} />
          ))}
        </Grid>
      </Stack>
      <div ref={ref} style={{ height: 1 }} />

      {isPending && <Loader size="sm" style={{ alignSelf: "center" }} />}

      {!hasMore && data.length > 0 && (
        <p style={{ textAlign: "center", color: "gray" }}>No more to load</p>
      )}
    </>
  );
}
