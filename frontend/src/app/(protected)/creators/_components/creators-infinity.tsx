"use client";

import {
  BrowseFollowersData,
  BrowseFollowersResponse,
  type FollowerWithMeta,
} from "@/lib/types/strapi-autogenerated";
import { Grid, Loader, Stack } from "@mantine/core";
import { useIntersection } from "@mantine/hooks";
import { useCallback, useEffect, useState, useTransition } from "react";

import dayjs from "@/app/lib/dayjs";
import api from "@/lib/api";
import { useQueryStates } from "nuqs";
import { discoverParsers } from "../lib/search-params";
import FollowerItem from "./follower-item";

interface Props {
  initialData: FollowerWithMeta[];
  initialPagination: BrowseFollowersResponse["meta"];
  fetchAction: (
    options: Parameters<typeof api.follower.browseFollowers>[0]
  ) => Promise<BrowseFollowersData>;
}

export default function CreatorsInfinity({
  initialData,
  initialPagination,
  fetchAction,
}: Props) {
  const [filters] = useQueryStates(discoverParsers);
  const [data, setData] = useState(initialData);
  const [page, setPage] = useState(initialPagination?.pagination?.page ?? 1);
  const [hasMore, setHasMore] = useState(
    page < (initialPagination?.pagination?.pageCount ?? 1)
  );

  const [isPending, startTransition] = useTransition();

  const { ref, entry } = useIntersection({
    threshold: 0.5,
  });

  const buildFilters = useCallback(
    () => ({
      ...(filters.gender && { gender: { $eq: filters.gender } }),
      ...(filters.country && { countryCode: { $eq: filters.country } }),
      ...(filters.language && { languageCode: { $eq: filters.language } }),
      ...(filters.type && { type: { $eq: filters.type } }),
      ...(filters.search && { username: { $containsi: filters.search } }),
      ...getDateRange(filters.dateRange),
    }),
    [filters]
  );

  useEffect(() => {
    startTransition(async () => {
      const result = await fetchAction({
        "pagination[page]": 1,
        filters: buildFilters(),
        scope: filters.scope,
        hasRecordings: filters.hasRecordings,
      });
      setData(result?.data || []);
      setPage(1);
    });
  }, [filters, fetchAction, buildFilters]);

  const loadMore = useCallback(() => {
    if (!hasMore || isPending) return;

    startTransition(async () => {
      const nextPage = page + 1;
      const result = await fetchAction({
        "pagination[page]": nextPage,
        filters: buildFilters(),
        scope: filters.scope,
        hasRecordings: filters.hasRecordings,
      });

      setData((prev) => {
        const existingIds = new Set(prev.map((f) => f.id));
        const newItems =
          result?.data?.filter((f) => !existingIds.has(f.id)) || [];
        return [...prev, ...newItems];
      });
      setPage(nextPage);
      setHasMore(nextPage < (result.meta?.pagination?.pageCount ?? 1));
    });
  }, [
    hasMore,
    isPending,
    page,
    fetchAction,
    buildFilters,
    filters.scope,
    filters.hasRecordings,
  ]);

  useEffect(() => {
    if (entry?.isIntersecting) {
      loadMore();
    }
  }, [entry?.isIntersecting, loadMore]);

  return (
    <>
      <Stack gap="md">
        <Grid justify="flex-start" align="stretch">
          {data.map((follower) => (
            <FollowerItem key={follower.documentId} follower={follower} />
          ))}
        </Grid>
      </Stack>
      <div ref={ref} style={{ height: 1 }} />

      {isPending && <Loader size="sm" style={{ alignSelf: "center" }} />}

      {!hasMore && data.length > 0 && (
        <p style={{ textAlign: "center", color: "gray" }}>No more to load</p>
      )}
    </>
  );
}

const getDateRange = (range: string | null) => {
  if (!range) return {};

  const ranges: Record<string, { $gte?: string; $lte?: string }> = {
    today: {
      $gte: dayjs().startOf("day").toISOString(),
    },
    yesterday: {
      $gte: dayjs().subtract(1, "day").startOf("day").toISOString(),
      $lte: dayjs().subtract(1, "day").endOf("day").toISOString(),
    },
    thisWeek: {
      $gte: dayjs().startOf("week").toISOString(),
    },
    lastWeek: {
      $gte: dayjs().subtract(1, "week").startOf("week").toISOString(),
      $lte: dayjs().subtract(1, "week").endOf("week").toISOString(),
    },
    thisMonth: {
      $gte: dayjs().startOf("month").toISOString(),
    },
    lastMonth: {
      $gte: dayjs().subtract(1, "month").startOf("month").toISOString(),
      $lte: dayjs().subtract(1, "month").endOf("month").toISOString(),
    },
  };

  return ranges[range] ? { createdAt: ranges[range] } : {};
};
