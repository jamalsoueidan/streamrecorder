// providers/ability-provider.tsx
"use client";

import { createMongoAbility } from "@casl/ability";
import { createContext, ReactNode, useContext, useMemo } from "react";

import { UsersPermissionsRole } from "@/lib/types/strapi-autogenerated";
import { AppAbility, AppRules, createAbility } from "../lib/ability";

type AbilityContextType = {
  ability: AppAbility;
  role: UsersPermissionsRole | null;
};

const AbilityContext = createContext<AbilityContextType>({
  ability: createMongoAbility([]),
  role: null,
});

export function AbilityProvider({
  children,
  rules,
  role,
}: {
  children: ReactNode;
  rules: AppRules;
  role: UsersPermissionsRole | null;
}) {
  const ability = useMemo(() => createAbility(rules), [rules]);

  return (
    <AbilityContext.Provider value={{ ability, role }}>
      {children}
    </AbilityContext.Provider>
  );
}

export const useAbility = () => useContext(AbilityContext).ability;
export const useRole = () => useContext(AbilityContext).role;

export const useIsRole = (...types: string[]) => {
  const role = useRole();
  return types.includes(role?.type || "");
};

// Custom Can component instead of createContextualCan
type CanProps = {
  I: string;
  a: string;
  not?: boolean;
  children: ReactNode;
};

export function Can({ I: action, a: subject, not, children }: CanProps) {
  const ability = useAbility();
  const allowed = ability.can(action, subject);

  if (not ? !allowed : allowed) {
    return <>{children}</>;
  }

  return null;
}

type RoleProps = {
  is: string | string[];
  not?: boolean;
  children: ReactNode;
};

export function Role({ is, not, children }: RoleProps) {
  const role = useRole();
  const types = Array.isArray(is) ? is : [is];
  const matches = types.includes(role?.type || "");

  if (not ? !matches : matches) {
    return <>{children}</>;
  }

  return null;
}
